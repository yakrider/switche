
RUNNING NOTES DUMP ON POSSIBLE WORK ON THE SWITCHENATOR PROJECT :

   --- temp stickies --- 





04.01.y23 .. starting to look at tauri migration .. so a bunch of quick notes and mile-marker type dumps here

	- so far seems reasonable and w/o significant roadblocks to dive into tauri migration .. first off, it wont be just a swapping out of electron for tauri .. a bunch of code will have to be moved from sjs to rust, and not just the winapi portions, but likely a lot of stuff upstream of actual render-ready lists .. so winapi calls, maintaining win-dat tables, exclusion filtering, icons extraction and caching, icon overrides etc
	- so to recap current setup, electron is basically chromium (w/o its v8 engine) running in node v8 engine .. so that brings both the browser dom/js and node-apis in the same context .. which means for us, we didnt have a 'backend' or 'frontend' and so we have a lot of that code intermingled (not including the winapi portions which have a clearer delineation via ffi)
	- now in tauri, the webview will handle the dom/js portions and the rust backend communicates with that via message passing queues (cmds/events) .. which means emitting/responding to msgs should be async .. so thats a poor match to replace our various winapi calls directly (i.e. relay winapi calls to backend, passthrough winapi responses directly to frontend), because the current code is written w expectation of just being able to make quick winapi calls, often repeatedly over some simple fn to gather data etc... so if we'll have to update the code due to that anyway, makes much more sense to just go with a more native redesign, while ofc trying to retain as much of the ui layer code as is
	
	-- soo, the rough outline for starters is as follows
		- we'll prep everything upto render-ready-lists in rust backend, and only send that to sjs .. and to send that, it prob makes sense to have the front-end maintain a hwnd map of win-dat-entries which the backend will actively update when there are any changes, and the actual render-ready-list can simply be a sorted/ordered vec sent over whenever there are updates to the list 
			- so that means we'll do all winapi querying, cur/last hwnd-maps curation, listening to win-event updates etc in rust
			- and ofc, any events from the frontend we'll route to rust as well (user action reqs on specific window entries etc)			
		- we'll also do all icon querying/caching/refreshes etc in rust backend, and similar to above, maintain an actual icons cache both in front-end and backend, and when actual entries in the map change (e.g. new icon encountered), we send that to the frontend to add to it cache, but otherwise, we just include in the win-dat-entries similarly maintained in front/back the indices to that icons-cache .. (should be fine for now and long while to not worry about actually removing icons from cache)
		- all filtering on the hwnd lists to gen render-ready lists also needs to be in rust, as just the size diff between the rendering list and full hwnd list is almost order of mag .. and likewise w any icon-override mgmt
		- and so, beyond the render-ready lists, we should be able to use most of the sjs code as is .. that includes ui event handling, search, grouping, tracking highlights etc .. which is also quite involved by now				
		
	-- aight, so as to actual step by step diving in to the impl ...
		- there's the laminar sample w sjs/tauri/vite, and although we'd not touch laminar/vite for this, might be a good starting point anyway to just get something up and going .. thats also in scala3, and its not clear if we should also take on that migration from scala-2 w this, but prob makes sense .. might as well do it while we'll be going in making massive changes there
		- the winapi parts actually is now much more familiar by now .. we already have did winapi in rust for krusty, and we'd have working setup in js to port over, so shouldnt present substantial roadblocks
		- the icons will prob be somewhat painful as we relied heavily on finding the icon-extractor .. but hopefully we can find some crate or samples for that in rust too (e.g. https://users.rust-lang.org/t/how-to-convert-hicon-to-png/90975/6)
		- for incr work, we should prob focus on the back/front comm etc and getting a representative window up first to derisk that ..
			- so first off, get a sjs/tauri setup going, full compilation, rendering/cmds betwn front/back, something to start coding in
			- re repo setup .. prob upto this, can do on any external test repo, and after this, prob make a second clone of cur switche, and in that do all the extensive changes to move over to rust .. that'll keep a working switche throughout!
			- then maybe do a minimal mockup of win-dat-cache and renderlist to send over (w mock icons) and get the ui up first .. 
			- then we can add all the actual winapi calls and the hwnd-maps handling in rust
			- and after all that we can flesh out the icons caches and icon extraction from files/exes/windows prob in that order
			- and finally, we start getting to actual new stuff ..
				- long in the wishlist has been extracting icons properly from windows UWP apps .. will prob be some digging into it, but we did have some code pointers on parsing manifest etc before, and any filesys exploration/load will be more comfy in rust for me than having to deal w js in the cur node/elec switche incarnation
				- next up, we could start looking at tray-icons, and actual installation in windows etc!
				- and ofc then it becomes meaningful to look at saving/loading configs .. incl for remembering window loc/size, loading excl filters if still necessary, possibly icon overrides if needed, maybe grouping choice, num-recents etc .. maybe eventually even the hotkeys!
		- anyway .. seems manageable in reasonable time .. gotta get started!
		
		
	-- associated adventures picked up : 
		- intend to migrate from sbt to mill .. thought being if I end up having to do any fancy configs etc (and the sample seems to suggest I will indeed), then its prob better to get on mill than try to wrestle with sbt and its configs .. plus there's prob a whole bunch of actual tauri configs etc, so getting on mill and its offering of manageable flexibility would prob be valuable
			- (sadly though, the sjs-tauri sample build is in sbt .. but even then prob makes sense to try and move to mill for this)
		- intend to migrate from scala-2 to scala-3 .. no better time than now, and certainly need to get on that anyway
		- do NOT intend to start on laminar for now .. it'd be cool, but we already have all ui stuff done, no point redoing anything
		
		- also just noting that if we needed to use npm dependencies, we'd have to use some more complexity to get it to work with either sbt or mill, though there are examples on how to get that working .. however, once we move all the winapi stuff out into tauri land, we shouldnt need any npm stuff for our sjs code at all! .. so that should make it easier
		- in particular, the samples talking about using vite or scalablytyped etc are basically for that .. and the eqv of what we're currently doing in sbt via scalajs-bundler-plugin to collate up our npm dependencies into our sjs output js files
		- for later reference in git: /lolgab/scalajs-vite-example, pstutz/scala-fullstack/, /keynmol/scalajs-tauri-example, nafg/mill-bundler etc
		
	-- step by step dumps (prob can delete later)
		d- 04.01 resume dump .. finish going through mill task and module sections
		- pull down tauri-sjs sample, pull down mill-sjs sample, get them both to work (hopefully both in scala-3, upgraded if needed)
			- should be able to ignore the portions with vite or bundler coz we dont need that for this
			- hmm, could consider converting something simple like kbd-evs-printer or TabsO-tree-opener to mill too
		- then try and convert the tauri-sjs sample to mill .. will be good exercise getting used to all of mill/scala-3/tauri
		- then can get back on the actual proj impl steps as outlined above
		
	

	-- 03.31, quick resume-later mind-dump
		- we see now that when vscode is open, switche lists a window titled 'Setup' .. its cant be brought to front, and shouldnt be there .. if switche is showing it, its got rect, title, is-vis, is-uncloaked .. so something else is presumably going on .. 
		- worse.. it looks like trying to do anything with it in switche, like closing or bringing-to-front etc might be causing switche to be stuck at 6%+ cpu usage, presumably meaning a thread is stuck .. not good at all!
		- found that visual studio comes with a spyxx.exe that gives some details and allows for searching windows by handle which can be found via say process-hacker etc .. its useful utility for reference (as ahk window spy requires viz windows), but it didnt show anything useful either
		- found this in stack-ov : https://stackoverflow.com/questions/7277366/why-does-enumwindows-return-more-windows-than-i-expected .. can follow up later
		- also, dont think we've tried to see which of our old exclusion rules are no longer necessary after we added cloaked check .. that prob needs a revisit too and hopefully a bunch can be cleaned out .. and those that cant might show some pattern that can be followed up on later
		- there was also mention elsewhere of some such windows being 'hung' as defined by ms (no msg proc for 5s apparently), and can be queried by IsHungAppWindow (and there's more about ghost windows and HungWindowFromGhostWindow etc) .. but doesnt feel like thats an appropriate (or cheap) way of figuring this out either, though prob good to have in the backpocket
		- also, in balance, since so far this is ONLY seen for vs-code .. might not be worth following up on, at least not until we've migrated to tauri as that's much more valuable
		- (also, just noting, apparently by now, we're far far behind on latest electron, not to mention node, scala2, sbt, node-gyp etc .. so even our cur switche is in need of tlc just to rebuild etc .. so presumably at this point just migrating to tauri might be better option than try to put more work into switche, esp if it involves dealing w winapi or any js)


04/25/2022 .. revisit re icons and exe names for UWP/store apps 

	- so its been a long standing (mostly minor) issue that UWP windows 10 native apps like Store/Settings/Calculator/Edge etc, as well as any store-installed apps show up in our list under ApplicationFrameHost.exe, and we couldnt get icons to those either
	- was recently, unrelated, looking at exe locations for one such app, and saw that relatively easily, once the actual exe path is available, one might be able to parse the manifest xml for the app and get at a usable (though prob not the most ideal) logo png asset to use for our purposes
	- now, extracting the path itself can be somewhat involved too, but seems doable on quick search .. and indeed even just showing the exe name in the list might be worthwhile spending some time on, even setting aside the actual icon acquisition for a bit
	- now, there's some sample code for those purposes, but those are C# code pieces, and not really going just the various win-api calls .. which might not be too bad if that means we can just write that in sjs code instead as they dont need to do much win-api calling (or for those cases we add js stubs as usual)
		- e.g. https://stackoverflow.com/a/36495656
	
	

0510y21 .. on getting switche working over on the laptop
	
	- prob easiest is to just install node, try and fire up copied over prebuilt proj, else try and rebuild etc .. there was some pain involved w electron builds, node-gyp etc .. for now just want a switche instance running
	- sooo, copied over the whole thing, and firing up from vbs brought up the whole frontend, shortcuts and all, so clearly electron and winapi querying parts were working, which was awesome .. and this was without even installing node separately(!!).. however, that has the prior sometimes seen aggravating behavior of not actually bringing the windows to front etc .. ughh .. in the old machine reboots fixed those, will try out here .. huh interesting, maybe its just that it doesnt work in remote desktop, but in the laptop (after restart) was working .. ughh 
	- huh, interestingly enough, it seems to work on laptop from reboot, rdp into that and it wont work on rdp, then get back on laptop and still wont work .. all the while when the rest of the ffi winapi to monitor the windows etc continue to work .. what a pita .. and after that happens, havent found any way to restore it to working other than reboot or logoff
	- oh well, fk it .. hopefully not gonna use rdp much, and if so should be tolerable .. did check out the evolved version of vistaswitcher thats now called alt-tab-terminator and is a paid app .. its nice works rdp or not, but still has no option for list only w/o screenshot, and even if could ask dev to allow that, also doesnt do grouped mode which I find very useful .. the guy does seem to have recently added type-to-search, which was THE major think lacking that got me to build my own, but oh well
	- umm .. although it randomly works sometimes lol(!) .. not sure if it will keep up, but its just worked rn, idk wth the deal is .. and then, after swithching that back to laptop didnt work, regardless of restarting app etc, nor did it work in any subsequent rdp either .. so basically maybe it works on first start then switching rdp or back both screw it up for ever .. worst part is the non-recoverability ughh
	
	-- aight, so, found a thing on stackoverflow that said the iffy behavior on bring to foreground can be helped by sending a keypress first .. tried it out and it does seem to work .. at least for a couple attempts, rdp back and forth etc still seemed to do activation fine .. we'll see if it lasts .. 
	- however, had to build in old machine and copy whole thing over again .. somehow screwed up the setup here trying to do a clean build, and then having to do the node-gyp and electron rebuild crap etc which quickly got unrecoverable .. so dont do that ever is the lesson ig .. otoh, looks like everything is literally just in the node folders, and ig at least as long as similar os etc just copying over was fine!
	- also there's some weird shit in both machines where 'sbt fastOptJS::webpack' wasnt updating the js in the bundler consistently .. was a pita and eventually just edited directly eqv to in code js .. gotta dig in more eventually ig, but deleting the bundler js file (just search in everything etc) does seem to recreate the updated one so meh
	- also, noting here that whether the electron process seems to end up having 3 sub processes or 4 or 5 seems to be unrelated, though was initially suspecting something there as in desktop there used to be 4 (sometimes 5), but in laptop mostly there's 3 and now it seems fine still
	

03/12/2021 .. starting to jot down some nagging observations/improvements

   - esp when things go slow etc, not sure why but after many weeks of pc being on etc, seems not catch all events etc .. so regardless, it becomes often enough after a while that it seems worthwhile adding some fallback periodic refresh mechanism
      - in particular, doesnt seem to catch win minimize/alt-esc etc events .. not sure if those are actually monitored
      - regardless, think might be worth triggering a refresh on things that would 'hide' the switche window anyway, aka mostly in background
      
   - also, refresh doesnt so far update icons, and sometimes icons themselves get out of sync and never update .. currently can do reload to get new stuff, but in theory could consider adding that to refresh and therefore letting it happen in background too? 
      - alt, could consider setting up something for periodic background non-batch icon updates .. just something that slowly sweeps through things periodically and updates visible stuff icons w/o much load
   


02/20/2020 .. on sporadic recoverable cases upon pc restart where switche fails to activate windows etc
   - very freaking painful.. and drives home the point just how extremely heavily I rely on this utility for my puposes
   - but anyway, initially was noted only upon updating pc, as that was only when i'd really restart, but turns out it can also happen after regular PC restarts.. basically it comes up and its window etc seems responsive and processing win msgs etc, but it just doesnt seem to be able to activate the windows it wants.. some stupid stuff reminiscent of windows deciding it doesnt meet the criteria to mess w fg windows etc
   - anyway, not sure what the deal is, but it seems to often be fixed in subsequent restarts
   - if anything, maybe its less likely to happen if letting the pc sit at login screen for a bit before logging in and to not do much to interrupt the startup sequence.. not even sure how certain that is, but feels that way
   - and think, at least one instance there was a case where only certain things like chrome werent responsive to it, and upon killing and restarting those, they started behaving again.. but def hasnt always worked and had to resort to restarts.. so who knows fkk
   

02/10/2020 .. notes on minimal prep before putting it out there
   
   - really prob does make sense to put it out there, and seems to be working mostly ok even w the faster rings w windows update.. so wanted to start jotting notes on what all might need to be minimally/progressively addressed while/before putting it out there
   
   - a buildable/releasable setup is probably very important, though one could argue its not essential before just putting it out there, should prioritize it though, so can give it to non-technical ppl as well who'd have way too much pain trying to build it given the gyp build pain
   
   - should add some minimal help section .. maybe just a link and page up top like the reload/refresh etc .. could be sufficient .. and might consider removing the DebugPrint part too, at least in release builds
      - esp since there's quite a few kbd shortcuts that likely wont be obvious to folk
   
   - prob want to have something that sits in the windows notification area .. esp since it currently can be launched multiply which dont play will with each-other .. at least having something in notif area would let people see it and try to close it out etc (might not be bad either as its standard)
      - prob means at least some behavior has to be programmed there .. incl quitting, but prob also some minimal config etc
      
   - at least for windows exclusions etc, would prob need that to be configurable to be usable for ppl w all sorts of other apps that might be weird too
      - and in theory the config could also be another link/page up-top, though can consider alternatives.. also should make that invokable from notif area icon when/if there'll be the notif icon implemented
   
   - on other possible configs..
      - could consider giving at least a toggle, maybe right up top or in configs, that lets the window stay/hide when not in focus (ala vistaswitcher)
      - and should prob think of some simple config backing .. appdata file, registry etc .. and prob consider how to release (installer/zip etc)
      - not sure how worthwhile, and prob might wait till requests, but at least some of the key configs prob def need to configurable, starting with ofc the most essential one to invoke it .. currently hardcoded to F1 (though there's the alt ones ig)
      
   --> as currently is, appears the thing is eating upto 4G of RAM after running for a while .. lol thats absolute madness .. gotta get that down!!.. might just be that its sitting around using whats given w/o doing clean up.. gotta look if there's some setting etc that shouldve been set/updated
      - though to its credit, thats just virt mem .. the working set in phys mem, though peaked upto 1G+ presumably at startup, usually seems to be around say 40M even after running for weeks
   
   

12/05/2019 .. quick note/realization on app launch/setup

   - hmm, so had always kinda been nagging that as currently used, in task windows, node hosting our electron app appeared under another node process
      - well, just curious finally, deleted the top one, and everything seemed to work fine, so appears the top one was just there from invoking the npm start really, and node could directly be invoked for the electron app
      - so after a bit of trying out, made another runner to directly call it, its in switche-invis-runner-v2.vbs.. the cmd is just :
         "C:\Program Files\nodejs\\node.exe" "D:\Sandboxes\git-repos\switchenator\switchenator-sjse\node_modules\.bin\\..\electron\cli.js" "D:\Sandboxes\git-repos\switchenator\switchenator-sjse\main.js"
         - the vbs just has some extra messy quoting to make the vbs invocation work

   - note that this still leaves a node process hosting the electron process.. which one could argue isnt exactly the clean packaged app like say for slack etc
      - so looking further down directly into the electron process cmd line and calling that directly, that too seems to work, and only has electron at root!
      - so created a switche-invis-runner-v3.vbs and now using that for startups, the direct cmd is :
         "D:\Sandboxes\git-repos\switchenator\switchenator-sjse\node_modules\electron\dist\electron.exe" "D:\Sandboxes\git-repos\switchenator\switchenator-sjse\main.js"
      - the vbs again has some extra quoting
   
   - do note that all three invocation styles do seem to work equivalently, which is nice, means any prior concerns about actual nesting of node engines are irrelevant
      - now, in theory, whatever the packaging others use for electron apps could be done mostly as is and could give a workable packaged exe hopefully!
      
   - a bit too absentminded, but noting down since ran into confusion trying to update a tiny amount.. think if not rebuilding electron etc, and just scalajs changes, just need to do 'fastOptJS::webpack' in sbt to build it (or directly sbt fastOptJS::webpack if in clean console)
      - and if want to launch w debugger, go back to doing in switchenator dir console, 'npm run-script start-dev' .. look in package.js for the options setup
      

11/2019 .. running list for wishlist thoughts etc

   - might be worthwhile to add in some coded-scrolling such that on selecting at least the very top of list, the page scrolls to the top.. 
      - as it looks like occasionally when the list is long enough and requires scroll, when the scroll wraps over or reverse-scrolled back to the top of the list, the auto-scroll for the underlying page just scrolls enough to bring the top entry to the top of the pane, while the rest of the stuff above is still above the visible area.. kinda feels weird and pointless, as expectation would be that if it scrolls back to top, it should look like how it was when we started.. specially since we have no other way of scrolling the page anyway, so we're stuck in that ui state unless we try some search thing that cuts down the list to fit back in pane

   -- allowing drag drop of groups for some mechanism of sticky reordering .. could be made to work w or using existing sticky counts based ordering too
   
   -- if not doing direct chrome integration via some app etc, could still consider making tab-outliner invocation a bit easier
      - maybe a dedicated key to bring that window up if its open?
      - although really that kind of stuff should just be done via ahk if desired
      
   -- have found a couple times wishing it could have fn added to actually open new apps if not open
      - one way would be to also cache a list of ever-used apps etc, and show them in search window below everything else, and start them if activated
      - though really, not sure if worth polluting functionality/focus w that, esp as can just do that w win startbtn, or Everything search etc
      
   -- would def be nice to have some persisting config implementation
      - could do at least stuff like easier configurable exclusion etc lists
      - would allow for more persistent ordering stats/mechanics too
      
   -- finally ofc, would certainly be nice to build some packaged soln now that its been mostly stable for a long time (despite wrinkles etc)
      - would open the way to actually having other people use it too, which could be nice in its own ways
      - plus there's always the worry that some next compilation it breaks etc because of the pain w building in win.. a solid app would feel a lot safer
      
   x-- getting rid of the nested node stuff... prob quite important before considering any packaging etc effort anyway
   
   -- could consider adding a slow background maybe per-entry randomized update of all things incl icons
      - mostly because every now and then, the icon gets extracted a point in time where its transient and sticks around, and therefore doesnt represent what it should actually be throughout its lifetime.. e.g. for some explorer windows, chrome saved apps etc
      - also there seem to be some occasional circumstances when spurious window entries hang around that disappear after a refresh.. could check to see if there's already some background refresh that does happen, but dont think so
   -- alternately for above (^^), could consider adding a simple shortcut say ctrl-r etc that requires just the particular in-focus row, maybe just to get the icon and details from hwnd .. honestly not that big a deal to a full reload (F5), but keep coming to it, so might be useful for point use
      - or maybe should also look to see if that trigger refresh button should explicitly requery icons.. should be faster than reload
      - note that can add icon querying specifically to the click action, and not directly to the refresh call that triggers which might also be being used in automated fashion at other times/events etc
      
   d- re the duplicates that show up and get filtered already for winamp.. maybe should add a more generic thing for anything with ApplicationFrameHost, and if there's another entry with matching title, then to filter that out.. typical use case that seems to cover windows-store etc
   


05/26 .. updates on better icon aquisition
   
   -- soo, good news first.. the js/winapi/jimp code did make it relatively straightforward to get the icon extraction going as alternate for old c-app and emitter based icon-extractor
   - and even the initial tests on querying actual hicon from hwnds worked out pretty nicely.. and looked like we might be wrapping everything up quick.. (lol)
   - however, the when going from single tests to running for full hwnd list, ran into a real pain w something just completely hanging the app/browser, so much so that it'd make it unreloadable, incl the developer-tools going awol.. pain in the ass to look around and fix
   - eventually, turned out that was literally from the SendMessageA calls to the hwnds hanging.. in the first seen case, seemed to be to a minor update box/window for vs-code.. but certainly there'd be many others as well and so on
   
   - for short-term, made it such that we only query those for say chrome and a few others, so we still get the usability of icons for chrome which we wanted the most, and still not hang.. but ofc it cant be a permanent solution, gotta find a more robust long term answer
   
   - looked through, and looks like SendMessageA/W is just synchronous by default, and just not the right thing to do, there's the SendMessageTimeoutA/W and SendMessageCallbackA/W, but the callback seemed too painful, and the timeout should have been fine for our purposes, but the freaking timeout version, which got working after niggling w double pointers etc, ALSO hangs on the same hwnds! .. ridiculous.. whats the point of a timeout if it doesnt timeout!!
   - so not sure.. will have to investigate if there's something I'm missing w its use, or else maybe try and go to the callback version.. oh well, but can wait
   
   - ughh, and this thing is slow.. defintely, noticeably slow for the startup anyway.. refreshes now consist of waiting staring at the empty bkg.. now the app itself is ofc very usable and snappy because of all the caching.. but we had gotten to a pretty fast startup/reload too.. kinda sad to have to lose that :(
   
   - anyway, much improved now w more offloading to later processing, also finally implemented callbacks to win SendMessage calls instead of asking for immediate replies, makes it such that we dont have to worry about hung windows etc, esp with a slow setTimeout check at time of request that comes back and uses fallback icon acquisition from exe if the hwnd icon didnt come around in decent time.. seems usable for sure, and other than maybe slight lag at load time, dont think really notice much slowdown at runtime compared to the ffi/c/emitter based prior icon-extractor, which now therefore has been removed.. 
   - maybe worth noting, had to have PeekMessage calls being made to actually hear back the callbacks requested by SendMessage.. reminiscent of SetWinEventHook, but at least for here, PeekMessage works, meaning can interleave it in same thread, rather than having to use GetMessage which pretty much ties up a thread.. also worth noting, for any PeekMessage call, all ready callbacks come in as available, not like one-to-one on PeekMessage calls, makes it much more manageable and allows us to just schedule a couple PeekMessages while requests are being made and let them go quiet otherwise.. works out reasonably despite the hassle
   

05/18 .. chasing on better icon acquisition
   -- so, esp as more and more chrome types get used, as well for the chrome apps, just getting the app icons has become and increasingly sore point
   - but since we keep pushing it out, has gotten to a point where have to write down accumulated research before they get lost
   
   - basically, looks like a more realisitc icon acquisition in windows is done is various stages, only the very last being to use the exe icon
      - a blog post on the logic :https://devblogs.microsoft.com/oldnewthing/20180301-00/?p=98135
      - a reasonable sample for getting icon handle here: https://codeutopia.net/blog/2007/12/18/find-an-applications-icon-with-winapi/
      - there might be other more extensive strategies to support win10/store etc app icons.. in particular for things hosted inside an ApplicationFrameHost.. some examples required looking through child windows for process, even looking through manifest of those for icons!.. does not at all feel worthwhile enough for the very small number of those that we encounter, which further might not work by just asking for window icon.. really, we mostly just want it for chrome!
      
   - next up, gotta figure out how to get from an hicon to a bitmap and from there to say a base64 str to throw into inline image data
      - 
   - hmm, electron seems to have a nativeImage object that can take a path to make it to image, and even a fns to read/convert toDataURL, which seems to give base64 data.. which would ofc be awesome!.. 
      - at the very least, might mean can just use that instead of the icon-extractor w its c++ dependencies/code
      -> do note that this woudl require us having electron either in npm dependencies, or combine the outer electron to the npm deps one..
         - and if run into issues w either, not sure how worthwhile the process might be, though in general, ofc itd be good to just have one like in other projects
      - but better ofc, woudl be to see if we can use that by just passing hicon..
      - https://github.com/electron/electron/blob/master/atom/common/api/atom_api_native_image.cc
      -- ughh, sadly, the api shows other than fromPath, nothing to go from hicon, and even for bitmaps, it wants a node buffer, so not clear if just extracting bitmap data from winapi and sending it will work as is, though might if ffi buffers are what it calls node buffer
      
      - one mechanism, and pretty painful too, seems to be via gdi32 dll.. basically create bitmap from hicon, then find ways to stream that out to data to be converted to base64 etc.. its a ridiculous pain just to get this much done.. freaking archaic mess
         - https://stackoverflow.com/questions/1818990/save-hicon-as-a-png 
         - https://www.autoitscript.com/forum/topic/181330-solved-save-img-read-in-mem-to-base64/
         - https://stackoverflow.com/questions/2830622/how-can-i-create-a-base64-encoded-string-from-a-gdi-image-in-c
         
      - realistically, trying to do all that stuff in js via winapi calls is prob asking for too much.. painful processes, difficult to debug etc
         - could consider trying to do so in a small win/c/NET app like the icon-extractor piece and incorporate it that way.. might mean starting w that code itself in trying to build it, then packaging it etc.. would prob be substantial pain for some marginal improvement like this
         - if considering so, can use js comm mechanism as in icon-extractor, and add C/NET code to take hicon and extract image from there
         - https://stackoverflow.com/questions/1818990/save-hicon-as-a-png
         - 

      d- hmm, also, found an interesting js/winapi only code for extracting base64 icon from exe files .. could be worthwhile to consider using just to replace our current extraction mechanism, and/or to modify to take hicon (or even hwnd) and use it for our purposes!
         d- https://github.com/SkaceKamen/win-icon-extractor/blob/master/index.js
         d--> ooh, this is pretty cool really, takes us a LONG way to where we need to be.. can ignore the rest given this really!
         
      - if looking for another cc alternative for npm/js use, the following is also worth noting:
         - https://github.com/pelayomendez/exe-icon-extractor/blob/master/src/module.cc
         


05/08 .. ughh additional niggles   

   d-- the thing seems to be excluding a bunch of stuff that shouldnt be excluded..
      d- the first explorer startups titled 'This PC' etc.. should take a look, its getting annoying
         - huh, although a wrinkle.. upon a reload, a 'This PC' tab started showing up.. so presumably was getting set to exclusion upon startup process?
         d- also, after the updates w title etc listeners, it shows up on refresh too, just not w/o a refresh.. interesting indeed
            d- presumably means when it starts up, it is inVis or w empty title etc, but somehow we're not catching when it comes back to normalcy
            d- yeah that was it, starting to listen/treat 'show' events as fgnd events fixes, that though saw an occasional phantom window, hopefully wont be common
      d- some native windows looking utilities, eg. ShellMenuView.. prob a bunch of others too
         d- and the above fix for 'show' events makes these start showing too, though these still arent closable from there.. oh well
      
      d- even ProcessExplorer..
         - huh, seems to be an interesting thing here too.. if reload while procexp window is open, it will show up (sans icon), and afterwards will pretty much never go away despite window close etc.. otoh, if reloaded once while its in tray, will never pick it up despite refreshes etc
         - so basically looks like it too might get some exclusion set, and maybe partly its to do w som sort of show/hide thing w things that go into tray.. so maybe once it gets registered as inviz window, maybe it never gets waked back up
         -- now nice part about it not showing up, prob could just add logic on fgnd listener to update that.. shouldnt even be all that costly really
         d- for it staying up though, not sure, maybe have to listen to win hide events? ughh
      
      d- ughh, and minimized things, when unminimized from taskbar.. dont kick off a fgnd event to listen to!!
         x- i mean how shitty is that.. freaking gonna have to put some dumb show/hide listener for it
         x- goddamn, this is even worse.. looks like minimize/restore sends 0x8004 which is an identical z-order-change cmd.. wtf.. means will have to refresh when hear that, as cant even know if things are coming to foreground.. how could they not have sent a fkn fgnd event then??!!
         x- seriously though, maybe can just ignore these and see how it still pans out, maybe really dont care about ordering like this ya know.. its not like the minimized windows are off the list, its just the ordering that doesnt update until other activity.. oh well, could just let it be!
         d- ok, looks like there's also 0x0016 and 0x0017 for minimize start/end... but even then doesnt feel worth the extra ev catching.. oh well
      
      d- at least for show/hide like for proc-exp, the 0x8002 and 0x8003 seem to fire reliably, so could use those, plus the 8002 for show also gives 0x003, the fgnd event, and we're already querying viz state on that, so we might not bother passing that event up, but the hide should be taken care of
      d- and for hide, could just really treat it as obj destroyed and see how that works.. maybe there's more pain to come from doing that, but fk it we can see how it goes.. alternately, could try and do a refresh on 'hide' events if needed to avoid other pain
         d- except freaking had to make an exclusion for self window as 'destroying' it on self hide report was making it not destroyable afterwards, as on coming back up, it would be excluded by our filter and not added back into list!.. goddamn, so stopped taking it out on hearing its own hide report ugh!
            
      
   d- there also seems to be some shite going on where on maybe say eclipse restarts etc where the window title is lost etc, things get updated into the list w exclusion set to true, and they pretty much never seem to get updated back again, so the thing never appears on the list afterwards.. ughh
      x- and not even refresh will fix it.. would have to do a reload to get those to show back again
      x- could consider never settting things to excluded via updates if they have ever once been non-excluded
      x- could also consider doing very periodic rebuilds.. say like once every hr or so, to get everything cleared up.. though feels very hacky
      d- think these might have gotten fixed after doing more strict use of cache by requerying things like viz/title on listener triggers
      
   d- on top, note that for mostly the very same windows, the F1 key doesnt actually seem to work either.. it just opens up help shit
      d- could consider overlaying that w ahk scripting to send something like our ^!{F1} key being used for global right-btn-scroll combos
   
   d- not really a big fan of not being able to scroll w/o having the pointer on the box
      d- could consider setting up ahk so that when the window is in focus, we'd send the global hotkeys we use for right-mouse-scroll workaround rather than wheel events.. could be a nice usability addition
      
   - also worth noting that we dont have any closing/end mechanism currently.. when running in dev and closing window, app continues to complain in the background.. eventually could consider doing some exit combo and/or try icon etc
   
   d- another niggle, partly noted way earlier, some apps like procexp etc continue to not get the right exe paths and therefore no icons either
      d- well, tried out w QueryFullProcessImageNameA for getting proc name, and that works too, and gives back paths like C:\ etc instead of \Device\ etc, so that can be used to simplify the code a bit for IconExtractor
      d- but looks like the reason things like procexp werent getting paths was because getting proc handle from pid fails upstream of exe path query!
      d- looks like real reason was asking for too much permission, using the QueryFullProcessImageNameA fn, only need 0x1000 for limited query, and that brings back a valid process handle when queried even for things like procexp, shell-menu-view and other similar utilities, and hence the right icons.. thats nice!
      - re icons, there's now only the lingering thing that maybe would be better if we could get the icons for chrome apps like hangouts/mail etc, but that's likely going to be a pain as we're not dealing w the icon extraction and just using that icon-extractor code.. 


05/07 .. note re right-click + wheel-scroll combo to bring up and use the app
   - so this is a weird place to put this note, but wanted to have use of that combo for one handed use, like we could do in old vswitch (before w10 made that start causing unrecoverable hangups).. but looked like there wasnt an easy way of setting such a hook, esp not w/o interfering w normal wheel/mouse operation
   - was trying out w ahk, and looked like a relatively small addition to the key scripts could allow for something like that in conjunction w updates to code here
   - so ended up defining some special global hotkeys for switche that match up w those triggered by ahk and make it work nicely that way
   - as an extra nice bonus, note that this will work w the mouse pointer anywhere on screen while regular scrolling on tasks w wheel would only work while the mouse pointer was in the switche window!
   - copying here for future reference if need be, the portions of ahk script that supports that usecase :
   
      ; somewhat roundabout way for allowing mouse-btn+wheel combos for task switching
      ; note cant have F2 for global hotkey for task-switch unlike F1, so using alt-ctrl-F2
      ; then subsequently, doing similar for F1 too just coz wheel makes extensive calls, and sometimes some apps still respond to F1
      ; NOTE that after adding RButton combos w WheelDown/Up, the separate simple RButton entry below was required to keep default action working when not in combo!
      RButton & WheelDown::
         SendInput ^!{F1}
         SetTimer, TaskSwitchRButtonChecker, -50
      return
      RButton & WheelUp::
         SendInput ^!{F2}
         SetTimer, TaskSwitchRButtonChecker, -50
      return
      RButton::SendInput {RButton}

      TaskSwitchRButtonChecker:
         GetKeyState, rb,RButton,P
         if (rb="D") {
            SetTimer, TaskSwitchRButtonChecker, -50
         } else {
            SendInput ^!{F3}
            SetTimer, TaskSwitchRButtonChecker, Off
         }
      return
   
   
05/07 .. only somewhat related.. but noting here since this seemed great, and wasnt obvious to find.. 
   - the following piece of code when executed in console, will start printing out ALL events.. can modify to filter a bit more on desired ones
   
      Object.keys(window).forEach(key => { if (/^on/.test(key)) { window.addEventListener(key.slice(2), event => { console.log(event); }); } });         
      
   - noting here that the value of that is for instance for the headache w the auxclick / middle-click 
   - basically, when viewpane has more content that fits so as to make scrolling feasible, even when scrollbar is disabled, the OS seems to be extra-smart and give the multi-dir-scroll circle at mouse pointer instead of sending auxclick to the window .. meaning basically if relying on auxclick for middle-click handling for other stuff in app, wont work when content goes past window bottom.. real pain in the ass.. 
   - oh well for the time being dealing with it by listening to mouseup and parsing for button but its still not great as its not really a click, and the pointer shape change done by the OS isnt exactly avoidable
   

05/01 .. quick recap before possibly letting this rest for a bit to catch up w other work
   - fundamentally its at a usable state! .. its smooth, def an improvement over vswitch, looks good, nice mouse/kbd support.. could live as is for a long while!
   
   -- among possible places to tinker more on..
   x- think was noticing at some point that the very nice resync to focused place is based on ids, and so if things move up down, it moves along.. and usually thats great, but sometimes thats less desirable.. e.g. when we do quick switches to last win after working for a bit while the positions have changed, even if an update happens pretty drastically on the switche list, would prob like to stay on the second index in list to switch to on a quick alt-tab like usage.. as it stands now, it could lead to some weird place if done quickly, based on whatever stale data happened to be in there
   x- related to that, is just the question on what might be the right thing to do anyway on these quick switches after a while.. should it maybe be locked or delayed until the data comes back.. i.e. say we do quick single F1-space thing, and it has a refresh queued but not come through yet.. maybe it should be smart enough to say, oh wait, things are-a-changin.. let me wait till I get the refresh back before attempting the switch, and oh, btw, when that refresh comes in, I'll make sure to keep the focus based on index by how far down the list we've been taken, rather than moving w the id of pre-refresh focus loc   
   x- anyway, worth noting though, that its not as big an issue as it sounds here, as just waiting half a sec etc for update before switching makes this irrelevant
   
   d-^-- note that a bunch of these above are now mostly irrelevant or not worth the trouble now that we have a fgnd listener making things fast
   
   - could go back to take a look at getting proper icons for things like chrome apps (hangouts, mail etc).. there's note below on where we could go revisit/search
   
   d- next up, ofc, would be search.. and itd be useful for sure.. 
      d- do note that we've started using other kbd shortcuts (e.g. close, peek, up/down) etc, and those are valuable, so maybe the search should be nested after some key (e.g. f or ctrl-f)... 
      d- alternately, could say that search is whats more valuable, and should be on immediate find-as you type, and things like close/peek/nav etc should be w ctrl key.. either is prob reasonable, and one could argue putting close etc w/o modifier could be dangerous anway, so maybe go w that
      d- note that it'll be just a bit more involved as for best key handling (incl bksp etc) we want it to be in an input box, which will then do its own kbd handling, possibly masking/conflicting w our global ones.. should set aside for when have time to spend on it, w/o having other pressing things pending!
   
   - hah, next up might actually be packaging! .. basically getting to a state its easier to start/run and/or share.. maybe even w/ others.. 
      - doesnt necessarily have to be an installable, but at least an exe rather than npm starting would be nice
      - also if/while doing that, prob will involve another look at the nested node mechanism for current electron usage too
      - and eventually, if get that far, would be nice to extract out the configs into text file etc.. at least for exclusions, maybe some timings/recents-count too
   
   

04/29 .. feature thought
   d- hmm, so this is a braindump thought, and might need mulling over, but consider adding a section up top w some recents, and further down w just groups
   x- could ofc make it a separate mode for the time being.. and modes persist while app is around, so easy to see which we prefer most over time
   i- main idea being that while for larger lists we want grouped shorts, for quick changes, we often want to go back to what we were working on 
   i- but its seldom deeper than say 8 or 10, beyond which the recency is of little value anyway (other than maybe at bottom but that prob not worthwhile)
   d- would also easily take care of the quick single alt-tab/F1 like usage where we just want to go to the prior window, but awkward (though doable) w grouping mode
   d- shouldnt be difficult to impl either, just a matter of adding some things couples times to the dom etc
   d- can think more about how it should play best w search.. maybe starting search gets rid of recents block (or grouped block, or has its own sort scheme)


04/28 + .. note on perf after getting to a mostly working state
   - so, we have a mostly usable working test setup now, lists all the windows, does activation, allows grouping by task, decent ui, fetches/loads icons too!
   - and its not too slow either, esp after the initial app startup once it gets most things cached..
   - so def dont need to redo it etc.. but had some interesting revelations as I've been looking at perf and the initial load time..
   
   - so, the bkg queries take some pieces of time, esp the first win query, there's also fetching icons etc, but those are indiv actually not that slow
   - and we were using the requestAnimationFrame feature so things could be timed w when browser wants to do rendering updates
   - it looked like despite those, at least when making frequent rendering requests, the thing actually was quite slow (was fixed a bit by bunching render reqs)
   - essentially, two shit things happenend.. because we wanted to jump on the requestAnimationFrame, the code got written to queue those calls on state change, and on render call, to actually re-render the whole freaking page again! .. that sucks, esp w all the scalatags indirection, plus just inlined icon images!
   - it does make code easier, but if we were doing our old usual stuff, we'd have kept handles on parts of the dom internally as we created them, and just updated those instead.. which would have been way faster whether we used requestAnimationFrame or not, although ofc we'd have to do that management ourselves
   
   - now, its not clear if its gonna be worth rewriting that part where instead of rendering everything, we just try adn update the changed elems
      - in particular, would mean keep array of entry elems, update when we have title changes or icons come in etc, or when grp/ungrp happens and so on
      - would also need to figure out ordering logic if dont want to re-render.. which could be thorny..
         - say a refresh happens, and couple entries moved up/down in the list.. not gonna be trivial to monkey-patch the dom, although could be done, by say walking on the old and new list, noting moved vs new/removed, then doing inserts and deletes as needed.. but prob a pain not worth the hassle
         - alt, if could have the elems created but not displayed, and browser is efficient when just 'placing' them somewhere as opposed to rebuild, could consider
         - and just noting, that if so, then doing similar w icon images would be good too, as there's bunch of inline copies
         - hmm, actually there's def gotta be a way to just move things around.. e.g. jquery has a detach/reattach mechanism, so similar must be doable in plain js.. its possible just holding on to an elem w a reference in sjs and using it elsewhere might already do it?
         - i.e for the last part, proposing to just use an array/map of rendered elems, then recreating the list putting them in right order might already be way faster than currently where the elems literally get created everytime?
         
   - so, w that in mind, one way of looking at what we did, is we acted like there was a virtual-dom while there wasnt.. in theory if we were using react, then we'd make the new page, react would calc the changed components etc and render just those parts.. that'd make it similar to our element caching solution, but w/o us having to do all that complexity, and prob w bunch other optimizations they do at their ends
   - but, obv def prob not worthwhile trying to rewrite this in react.. esp at this point, though maybe should really have considered that before starting
   - eitherway, its a good reminder to pick up on that before starting something like this again, and hence noting here for future reference/reminder.
   - and finally, taking a look at react, it might not be that big  to learn/change to impl for me anyway, feels somewhat similar to scalatags in use!
   
   -- also, just noting that that for the end purpose.. to ACTUALLY USE IT .. given that its already pretty darn fast after init, should really focus on a bunch of other more essential improvements rather than going down a perf focused rewrite of big chunks..
      - e.g. just to list out a few .. electron hotkey bring up, search, mouse wheel handling, kbd up/down etc handling, window close etc enchancements!
      - hmm, although come to think of it, when getting around to the search impl, could look at doing some of that perf rethinking as we have to move rows up and down.. might also be worthwhile taking a look at the dynamic search think lihaoyi had that was pretty efficient I think
      - http://www.lihaoyi.com/hands-on-scala-js/#Re-rendering
      - lol, and just doing the scrolls and activations will prob require to have a more code-addressable dom anyway unlike our constantly regenerated stuff.. just even for things like doing tabs or mouse scroll to move to next elem etc.. so either way, we're headed that way
      
   -- work-map on going fully to small updates rather than render calls on quick changes
      - for updates to titles, exe/icons etc, is straightforward.. just regen the elem, replace the one in map w it, replace the node in dom w the new one
      - for initial stream of windows as they come along, bit more involved..
         - currently renderable list is generated enmasse, by taking curList and appending from prior list as necessary, old stuff is only removed on timeout
            - to be responsive to closed stuff, maybe also means should either go back to kicking cb timeout only for win calls not for icons, or separate them out
            - actually maybe even means we should kick cb call only for EnumWindows call, not even for titles, exe etc
         - can update WinDat entry, if is renderable, can compare entry w prior, if change, can render that div
         - main q is how to handle updates that make things out of order..
            - note first, that we have.. a cur WinDatEntry list (partiall filled), a prior full dat list, a combined render list, an elem divs list, and actual dom
            - again, for data updates in existing order, should be easy.. check cur dats, ensure in same order, find elem div, update it (dom will reflect change)
            - if new item appears, we already check prior etc and create a cache-mixed entry in cur list, prob easiest to update that entry in elems list, then trigger rebuild of dom? .. prob faster ways to do it later, but ok for a start.. avoids doing insertions/removals on dom, though honestly, this is the most common change, as happens everytime something moves up/down list.. so afterwards should see if need more perf improvement
            - hmm, though could also just remove that item (if any) from dom, and hook up new item there (insertBefore, removeChild etc)
            - otoh, if doing a rebuild dom (but w/o rebuilding dat list etc), could queue that for refresh, not sure if worthwhile
            - for inserts for ordering etc, will have to do separately for recents, grouped, search!
            - actual queries wont be that bad though, have ready list, just gotta search there, find next/prev there, then call dom w remove/insertBefore
            
   d--05/07+ -> huh, seriously considering if it makes sense to go ahead w the above, or just try and get a win event listener hooked in!
      d- afterall, even w the improvements w the in-line updates possible from above, still will be the case that the ui refresh will happen AFTER the hotkey is pressed etc.. so there's really only limited improvement this can have, while the background listener would make things pretty much be ALWAYS updated!
      d- further, we already have native hooks to a bunch of other stuff, this might not really be all that different anyway
      x- plus, we could then get rid of the background 30s full call which is just as wasteful anyway, maybe even more so than listening to foreground wnd
      
      d-- ughh, looked straightforward at first, but ended up losing a bunch of time for not seeing this one essential limitation in the docs for the SetWinEventHook api call : 'The client thread that calls SetWinEventHook must have a message loop in order to receive events.' .. and that looks to be a freaking unending wait on 'GetMessageA' w/o which the hook callbacks dont happen! .. unbelievable!
      - so looks like, if we want to do so, either we figure out worker threads in node and try ipc back to main thread, or maybe even consider some c impl! goddamit
      - fk, looked like using worker_threads would work out nicely, even got a minimal sample working in pure node w the --experimental-worker flag, but that doesnt seem to work w electron, and trying to upgrade node to higher version than LTS to not have to use the flag makes all kinds of shit not work w node-gyp
      d-- hah, had to use npm 'cluster' package, but it now works!.. not even all that hacky.. just a thread set out in main that sets up a listener for the events and calls out to elec app w the new fgnd hwnd upon change.. nice! .. think might leave the direct sjs api code there too for this commit
      
      d- lol, there's always the follow-up long tail on things w promising starts.. so after the fgnd window change listener, it only makes sense to add something to listen to window close events.. even if that need be on separate thread/loop if otherwise have to filter through too many events
      d- and if doing that, might as well do the same for title change events!
      d- hmm, and at least for title change events, could really just do surgical updates to title span, and might actually be worthwhile to do so, as there could be quite frequent title changes for things like winamp, pages that make dynamic titles, chrome tab changes etc
      x- and much later, if wanted to, could also do surgical removal for window close events, but that seems less worthwhile as that should be a rare event anyway


04/25 + .. taking stock and immediate paths forward

   d- having gotten past the massive initial winapi blockage, a huge amount of progress has been made, though new issues do keep surfacing..
   d-- have a minimally working setup, w actual listing and switching working!
   d- took a bit to get at the flakiness on activation, but activating after a tiny timeout to let win register the app did proces last input helped a lot!
   d- ended up working a bit on the ui/presentation .. and its already not bad.. thats nice!
   d- some very decent caching and call optimization has been built in.. gotta say its not bad at all speed wise, after the first startup
   d- getting at the exe has been a pain that still needs addressing.. the getWindowModuleFile was a red herring.. only works for windows of same exe process!
   - ugh the webpack dev server didnt look like would pan out either, its built into sjs, and doesnt play well w electron
      
   -- next up sets of things to focus on:
   
   -- impl internals   
   d- def gotta get that exe extraction working.. not least because we wanted that for all of exclusion filtering, ico extraction, grouping/sorting!
   d- really want to work on the icon work too, but maybe can wait and see how far just the exe names can get us, though feels it might be crucial for usability
   
   -- new functionality over vswitch
   d- think we're already actually faster than vswitch given all the caching, esp for anything after first invocation.. its awesome!
   d- the first key improvements ofc, would be sort by app mechanism.. gotta put than in earlier rather than later!
   d- and soon after, want to start on a find-as-you-type search.. right in there, maybe w a box on ribbon.. would be nice
   
   d- later could think of less missed enhancements.. say considering adding a close mechanism, say via middle click, or an icon on hover, context menu etc
   x/d- might be too much, but could consider what it would take to do selective preview.. say when holding onto something.. would be useful for windows w tabs
   - way way later, could revisit that thought on making an exension for chrome that could feed this tab info data.. but w TabOutiner around.. prob not worthwhile

   -- ui work
   d- need to start putting in at least some minimal keyboard handling.. even if just inside page for now.. for sorts, search, grouping etc
      d- gotta add in the outside hotkey handling for the elec app too, just to get the thing to show up on hotkey, and maybe hide/reappear too
      d- basic showing of elec window on global hotkey work, added that in main.js, its sufficient
      d- added a way to share a handler from page to global and have app access it that way.. so the global hotkey can be passed along to the page too
      d- added minimal way to hide the window directly from page by going to winapi instead of adding rpc to app to make it do that for now.. so Esc to hide works now
      d- got to work on actual kbd handling now for repeated hotkey, up/down btns, space/enter for activation etc.. (prob want to update how we do dom elems for that)
      
   d- need to get mouse scrolls working better too, as think the scroll on elems w mouse as in vswitch works better than just having to always point to stuff
   
   - might want to take a look at the mention somewhere on actually getting at module exe rather than just process exe.. will have to search to find again, but the hope is that maybe for chrome saved apps like Mail, TabOutliner etc, that might lead to proper icons rather than all just having chrome (anyway, no big deal)
   
   - should revisit unicode char display.. dont seem to be working despite making calls to winapi unicode fns.. prob something w electron or html page encoding
   
   -- misc setups
   - and really at some point, gotta try and merge in the two nested electron setups for this into just the sjs ele.. though might not be easy/worthwhile yet
   - same w trying to get webpack/hot-reload working, but given already tried the ovious stuff, and its a tradeoff w actual dev. and it gets less useful further along, will have to see how much it still makes sense as a bunch of the early dev gets completed
   

04/~26 .. about that icon display stuff
   - so actually writing this following up on tasklists above.. that icon display actually seems surprisingly involved
   - so there does seem to be a guy's effort to take a stab at it, and its decent too.. 
      - https://www.npmjs.com/package/icon-extractor .. http://sciencevikinglabs.com/icon-extractor/ .. https://github.com/ScienceVikings/IconExtractor
   - however, that too goes about the round about way of using a c process to extract the icon the tx over to node as base64
   - but could be a pain integrating that c included project.. although could also be straightforward, so prob def should try it out via npm quick first
   - but if its any pain, been considering why not just do it offline.. for personal use for myself might not be that big a deal, and could be lot quicker to have it
      - basically, on switche side, keep an updated running set in disk of all exes seen so far
      - and have it check some other config file to see if there's matching icons for those to load from some given location, and if so to do it
      - offline, we could use some other seprate utility to extract icons for exes, maybe based on switche's list, or proactively at first too, and save them
      - thats it, would make it way straightforward to get it running, and keep all that shit complexity out of the node/elec project
      - and def there's piles of utilities to extract icons from exes, incl standalone tools, as well as java libs if so desired
   - well hot damn, tried the icon extractor.. and a little bit of fiddling around w translating around js data vs sjs etc.. but it freaking mostly works!
      - and the base64 icons appear to not be all that big to be a pain either.. its nice!
      - now the code's a lil messy w global pseudo registered callbacks etc, but damn that was lot easier than how it could have panned out!
      - note that in sjs node, it installed the reqs when the updated build.sbt was reloaded and webpack ran, but since ours is running from an outside electron/node, had to install it there manually for it to be found I think, but given the murkiness of many things breaking/fixing together, who knows


04/23 .. moving these impl notes from code to here, as they are quickly getting outdated, but could be useful for thought-evolution reference..
   -- some thoughts on rules..
      - note that it might be easier to explore these using jna code from the initial switchback project
   - not sure if all things with empty titles can be ignored.. but maybe ok to start out with
   ?- but most things w len/width 0 windows can be ignored, and most, but not all, have empty titles..
      ?- meaning checking title can be an initial shortcut, but if find empty, can go ahead and check win sizes
   - looks like there's 'Desktop' window named 'Program Manager' usually at bottom of stack, not sure if should exclude it
   - there'll be a bunch of other spurious windows explorer windows.. looks like filtering for empty title should clar most/all of those
   - some w hidden windows should always be ignored.. like our own ShakenMouseEnlarger.exe
   - most things from ApplicationFrameHost.exe can prob be ignored
      - especially if they have dup titles w some other windows thing (e.g. Store, Settings)
   - winamp seems to give two windows too, size wise looks like one is for the titlebar-only/windowshade mode.. but doesnt matter which one we keep
   
   -- so anyway, will need some mix of generic and specific rules
      - abstract rule by exe .. specific instantiation for ShakenMouseEnlarger
      - generic rule for empty titles
      - abstract rule by exe/title .. specific inst for explorer 'DesktopWindow'
      - abstract combined rule .. specific inst (dup ApplicationFrameHost), inst (dup winamp)
         - e.g. chained AND rule w/ a generic is dup title, and inst of check exe, maybe even check exe of other dup
         
   - hopefully can avoid having to read win sizes etc.. likely to slow things down etc
   - hopefully dont have to rely on list order either (e.g. that ShakenMouseEnlarger/Start are at top, and the desktop is at bottom
   
   -- as for actual processing strategy..
      -- we want to make approx presentation fast, then increase accuracy as we go along
      - display pre-existing render immediately
      - then maka a EnumWindows call w streaming callbacks w just hwnds
      - have callback handlers (atomically? no, js is single-threaded!) update an ordering holder, or update a new one per winlist call
      - on each callback, check if hwnd already in cache, if so update display w it in right position
         - if not in cache, fire off call for isVis and get Title checks, when those are back, update cache
         - given results, if meet inclusion criteria, update/reorder display, if need more info queue more calls (e.g exe loc)
         - ditto w handling any further calls make async like w results from exe loc lookup
      - for the ones in cache, and now displayed, still fire off lookups, as will want updated title at least
      - as things come back, stuff that doesnt come up shoudl move lower and lower in queue, should prob put a timeout to remove them after some time
         - could also explicitly queue a check for isWindow before removing the ones that dont come back.. not clear if should leave those in cache
         
      - also, since all this might (hopefully) be really fast, and its pointless redoing layout repeatedly w/o display, should call requestAnimationFrame(cb)
         - will let us naively continue making page updates on any winapi callback, while the re-render only happens right when chrome is about to repaint (~16.6ms)
         - also, its just a one time request that get collated till next paint, so everytime we get win callback that precipitates a change, queue it up, thats it
   
       

04/21 ++ .. post minimal workable path notes ..
   
   - k, so, dates above might be deceiving, but finally got done through the last part of getting basic win-api working via ffi in an electron hosted node app, all of which makes most of the second half of the long note below.. but anyway now that the minimal mechanism is validated, although more can be done there, can start thinking about what exactly is next on going about shaping things here quickly
   
   - so first off, there's still that disconnect thing going on w electron launcher/host, and the frontend like sjs bundler connected to the index.html that gets loaded into the electron page.. not that big a deal since still can get pretty much full access to node stuff from the sbt/bundler managed part, but at least as of now, that isnt doing anything electron.. eventually could look into seeing if can eliminate the external stuff jsut to fire up electron
   
   - also note that, the bundler when its trying to look up stuff, 
   
   - eitherway, as it stands, among the few things we'd prob want electron functionality is in registering a global shortcut.. 
      - now ofc its quick and easy to do that in js, and examples are straightforward (https://electronjs.org/docs/api/global-shortcut)
      - if so, we'd have to pass those events into the page.. and currently we dont have very good comm between those.. 
      - presumably we could do so by making the bundler compile not just as an app, but as app+library 
         (https://scalacenter.github.io/scalajs-bundler/reference.html#bundling-mode-library-and-application)
      - then could just call the desired sjs fns from js code as necessary, as should be able to import the bundle js in any js code just like in index.htm
      
   - would prob also want to update the window to be more reasonable, but for now prob nbd, might as well keep going till more usable
   
   d-- def first in line for functionality testing, is to make sure that can do activations as well, otherwise, kind of pointless !!
      d- oh yeah.. shit def works! .. freaking feels nice man, to finally get to this point after unending stream of frustrations!
      
   - next up, is getting the list of windows, and minimally at least, the hwnd, back to scala via return val rather than printing in console
   - the other half on making the make-fgnd by passing hwnd should be even easier
   - then can have a minimal ui w printed out the titles in ui as links, and having them clicked to activate the window!!
   
   - hmm, although given we're this far, and know how things work a lot better.. could be worthwhile to try and see if we can do the win-api directly in our code..
      - basically to make facades directly using ffi, and use that as npm dependencies for bundler.. making facades should be that bad
      - and further, it will give MUCH better control and easier iteration to make things fast like 
         - e.g. calling get window fns w callbacks to update dynamically, 
      --  impl notes on this
         - to pass around callbacks etc, worth looking at http://www.scala-js.org/doc/interoperability/types.html
   
   - and then can quickly start iterating on usability, as all that is just sjs stuff that can be done w/o much pain! 
   
   - and while doing the sjs ui stuff, should REALLY look into the 'webpack-dev-server' as that would save good time and annoyance on code/build/test cycle
      - https://scalacenter.github.io/scalajs-bundler/cookbook.html#webpack-dev-server
      
   - and then ofc, lets start eating eating our own dogfood.. sooner the better!
   
   - hmm, and will have to figure out what makes sense for bkg tasks etc.. basically doing periodic polling to keep querying data etc
      - esp if looks like we'll be stuck waiting for winapi calls in any thread etc, def gotta figure out async kind of work to have things be snappy
      
   - ugh, and there's work to get icons etc, even just to have minimally usable stuff, not gonna be handy to use w/o visual guidance on apps etc
   - and ofc, gotta see what makes most sense to querying the details other than just the title etc for the windows.. 
      - want enough at least to be able to group by exe, filter out stuff, lookup icons, etc .. and hopefully keep it fast and/or cached
   


04/05 ++ .. another dive-in

   - aight, so the last one sputtered out, w the sjs setup just not working to get ext js modules working at all, let alone getting to try out ffi
      - but saw that maybe there were improvements in latest sjs versions to make that a bit easier, though all the material etc we've based shit on is from older versions and just trying to ram it through just wasnt working
   - so now, gonna try and restart the process from a bit more grounds up fashion..
      d- first take the more recent sjs tutorial etc to build up a clean skeleton project in sjs/node .. no electron, no ffi, no x-proj deps etc
      d- try and get basic js import/require working there, and if so, can see where to go from there
      - (and on plus side, might get us much better situated to be able to deal w electron, ffi etc incorporation going forward too, having understood better from the grounds up how the integration etc ends up happening
      
   - more concrete, start w basic tutorial, try out import, if really get stuck, can ask guys in gitter for samples/pointer/link to get that working
   
   - ok, so for more concrete stuff on what exactly the sjs 1.0.x.Mx milestone versions vs 0.6.* versions, here's the starting point
      - https://www.scala-js.org/news/2017/07/03/announcing-scalajs-1.0.0-M1/
      - think biggest stuff was about moving core dependencies out etc, so prob wont be too bad other than code reorg and so on
      - and uh, best of all, the 1.0.x.Mx path explicitly is setup to deal with js globals such that the nodejs 'require' works nicely.. hmm
         - although realistically, that only ensures the require, to use from sjs, still need facade etc, at which point, as it suggests, should just use the usual suggested mechanism of '@JSImport and/or CommonJSModule', and create a simple facade for the calls
      
   - finer grained log/notes
      - lots of shit w things that break from default tutorial at https://www.scala-js.org/doc/tutorial/basic/
      - so instead refer to https://github.com/scala-js/scalajs-tutorial which seems to be more recently maintained
         --> but make sure to be on the 1.x branch of it!!
         
      - next up gotta look up the sjs bundler that interfaces better w npm packaging etc, though for us, could also go the ProvidedJS route
      - sjs-bundler also has links to examples for writing simple facades to js! sounds like exactly what we wanted!
         - https://scalacenter.github.io/scalajs-bundler/getting-started.html
         - maybe could actually try that, but w/o the sjs bundler, i.e just w the local js (via ProvidedJS) and a facade for it
         - also noting that a facade in sjs for js module/file is not that different from a facade for winapi via ffi in js itself (which we did/verified earlier)
      - as for doing both sjs bundler (for npm dependencies/facades) and provided-js, there's some links here on how that could be made to work
         - https://github.com/scalacenter/scalajs-bundler/issues/190
         - and really, think the bunder is the way things are moving forward, and the rec for 1.0+, so should try and go w that unless get stuck there
      - note ofc, that if bundler works well but provided-js becomes a pain, could also just try to go by some win-api npm package that think we've run into before as well etc, and if necessary write facades for those which dont seem too bad.. although being able to do local stuff will def be handy
      - also, the bundler has a nice cookbook, which, at this time, will be the most up to date, and give good broad instincts too.. should really go w that
         - https://scalacenter.github.io/scalajs-bundler/cookbook.html
      - ooh, also note that there seems to be at least one skeleton for sjs/electron w the webpack/bundler branch !
         - https://github.com/massung/scala-js-skeleton.g8/tree/webpack
      - there's also a footnote on packaging for electron w bundler merged into some tree of that cookbook, not sure why its not (at least currently) in trunk
         - https://github.com/scalacenter/scalajs-bundler/blob/4e121bfb1aeb743af500887635bd723c183979a4/manual/src/ornate/cookbook.md
      - on setting up actual JSImport schemes, this link should help get the basic idea
         - https://www.scala-js.org/doc/interoperability/facade-types.html#import
         
      -- sweet, so using simple file position import, ext calling seems to work! thats awesome.. gonna get that committteddd!
         - hmm, so wonder if its worthwhile trying out simple ffi based stuff now..
         - nah, should go to elec based stuff and try and get local import working there first.. that'd go a long way to getting us set up
         
   -- so, 04/07 here's a checklist on various partial stagest to getting there (i.e to sjs + js-local-imports + electron + win32 ffi)
         d- 0.0.1 - js, js-loc
         d- 0.0.2 - js, js-loc-ffi-w32
         d- 0.0.3 - js, js-loc-ffi-w32, elec (elec-win32-test)
         d- 0.1.1 - sjs, sjs-js-loc (sjs-node-ext-module-test)
         d- 0.1.11  sjs, sjs-elec, js-loc (sjs-elec-local-js-test, others) .. note that its sjse + js-loc so far NOT sjs-js-loc
         d- 0.1.12  sjs, sjs-elec, sjs-loc (sjs-elec-local-js-test, others) .. aight, direct path works apparently for JSImport, will have to see if ok for ffi too
         ?- 0.1.2 - sjs, sjs-js-loc, sjs-elec
         ?- 0.1.3 - sjs, sjs-js-loc, js-ffi-w32
         ?- 0.1.4 - sjs, sjs-js-loc, js-ffiw32, sjs-elec
      - so given we've finally gotten 0.1.1 (sjs + js-local) working, q is do +sjs-elec or +ffi next
         - think def should do sjs-elec next, as might be able to do ffi just from js, as ffi parts are only called from js imports
         
   - so starting w the sjse-elec test.. doing a separate build since the old one is a xapp, and older versions
      - ended up buidling from 'sbt new massung/scala-js-skeleton.g8 -b webpack'  (i.e. from that github repo webpack branch)
      - fk, those dont work w 1.0.x milestones.. for now going down to 0.6.27.. will see how that pans out
      -- uhh, that shit also has weird setup, not even clear how the electron shit actually gets integrated into sjs.. gonna be a pain.. 
      
   - fk, trying back now on sjse-xapp.. we have some more insight from the js-elec-w32 app tests, maybe can leverage that to get the old sjse app working now
      - dammit, even w fkn around, looks like there's incompatibility between using the scalaJSLinkerConfig for module import (as used for local module import) which makes it not work w jsDependencies, and how the electron app structure was
      - suggested soln is to try adn figure out how to use scalajs-bundler w that shit.. prob means should go back to the non-elec version and get that working w/o the scalaJSLinkerConfig? (ref : up top at https://www.scala-js.org/doc/project/module.html)
      --> so, the old sjse format uses the jsDependencies in sbt crap, and thats not gonna work w JSImports, so maybe this isnt worthwhile anyway, and gotta go back and revisit the massung version and see if can set that up for easier electron use then instead?
         - and while at it, could first try the inclusions to make sure those work (say from console) before dealing w actual electron crap
      -- wait a sec, the working sjs-node-ext-module-test still doesnt use bundler, and uses scalaJSLinkerConfig and Imports..
         - so should be able to get working w that for sjse (hopefully letting jsDependencies in sbt do all but local shit)
         
   - goddamn, so gonna start a clean 'sjse-quickstart', just to get to a point w working elec again, and w/o any of the cross-proj bs.. then can move on from there
      - uhh fk .. feel like was close, but now appears we need to be on 1.x versions, while the only thing the dumb mscharley facades available are way old
      x- hmm, coudl try adn force use whatever dependencies are available and see if that works out
         - nope, shit be pain in the ass
      - or could try and just copy over the facades and keep em around for local use
         - well, brought over the dep files, tried to compile, copmlains of @JSExportDescendentObjects annotation, orig being in sjs 0.6.9 and sbt 0.13.9
      --> fkn sob, this stupid shit, after all this, getting this to compile. upgrading all of those dumb elec facades to work w sjs 1.x , and STILL gives the fkn error saying cant find the modules.. un fkn believable
     
   -- 04/21+   
   -- k, so at this point, think it might make most sense to go back to that massung 'sjse-elec-local-js-test' which was already set for webpack, and try and see if can just get that to print/play nicely on electron launch.. shouldnt actually be that bad if its all setup, and since we're now quite familiar w how the launches etc work there too.. prob our best bet.. and maybe if that works, but we want to come back to our setups, it might give clues on whats needed to get things to work w webpack too   
      - fkn shit, that thing, while it comes up (note to use fastOptJS::webpack instead, and checkout the webpack branch), it doesnt really seem to have the electron and regular sjs/js/html parts connected.. whatever the 'left as exercise for reader' part is, is fkn infuriating... i tried a bit, but really prob not worth fkn around w something that the guy didnt even try out.. who know if its straightforward or just stuck up in painful shit
      - (do note that, on trying to build w webpack, it complains of a bunch of shit and assertion failures, but does seem to create the right js bundles!)
      - and besides, it has no/minimal elec support for sjs.. its all in js mostly.. so even if get it working prob a continuing pain in the ass
      - the minimal sjs connection though, is there.. i.e. the bundle calls its 'main' in scala, and that executes and prints in console, just the elec part sucks
      -- ugh, turned out the simple integration just required that the div i'm trying to pullin main code was defined in html before the bundled script was included.. dammit that sucked!.. anyway, we'll see if this is an adequate way (elec integration but more like a page call), but at least we can move ahead from this part.. the stuff below about trying to make use of local js though still applies 
   
   -- ok, here's a round about thought.. so the pain w that massung webpack version was connecting w elec.. but why care about that, we have other mostly working samples for that part.. the missing stuff there was trying to get the sjs w elec to load up local js stuff right.. and that was what we were trying to get to by using the webpack bundling shit for our sjs compilation.. until we got stuck wasting time on that template's elec setup...
      - so first thought from there would be to try and take the bundling setup from there onto other working sjse setups.. and thats not a bad idea
      - however, for that to even be worthwhile, we should def test out that w the bundling setup, we actually can indeed use local js stuff!!
      - and that could be tested out just from console w/o elec shit, so should get that figured out and tested first before trying to take that over to other sjse!!
      
   - well damn, that webpack stuff does seem to pick up local JSImports and its prob doable to run w it the whole way.. now just gotta make sure ffi works too
      - man, havent even looked at ffi in a LOONG while.. we'll have to see if we can brush up quickly looking up old working shit.. glad had separate samples!
      - wish there was more stuff on that I had written down below than seems to exist.. fk.. think beyond just requiring/installing ffi, it reuqired for electron to be rebuilt, likely using the electron-rebuild in dev-dep, and that in turn might need the node-gyp.. and basically that the app will ONLY work with such a recompiled electron.. now if desperate, could try copying over that electron/node_depencies tree over, but that seems bone-headed.. should try and get this working, then diligently note things down to make it easy to follow through when inevitably will run into it again
      
   - aight, so starting w direct ffi from node (same as in elec-w32-test, but now for sjs-elec-local-js-test), will later try for its sjs node_modules
      - so just to see, tried to just add the dependencies to package.json and install/run .. the install actually called a node-gyp rebuild.. which despite complaints, esp about not seeing a binding.cc, seemed to eventually finish w all the c stuff, realistically though, think it only did the ffi build, nothing for electron itself.. either way, when trying to run it fails complaining about dll binding etc
      - so now, trying to do an actual electron rebuild.. looking up at that reference again.. its below.. basically three cmds
         - 'npm install ffi', ' npm install electron-rebuild', ' .\node_modules\.bin\electron-rebuild.cmd'
      - the node-gyp was installed globally previously, and so not needed again
      - and thats it for this! .. after that w the copied over win-api ffi code, printed out the list of active windows !!
         
   - alright, now there's one big hurdle left.. trying to get that to actually be usable from electron
      - first blush, since its local, gonna try and see if can just move that to local file, and hopefully not have to install any of the shit into sbt's own version of 'node_dependencies' that its compiling up to later put into webpack bundle.. fk we'll see
      - huh, interesting, on quick attempt, sbt webpack fails saying it cant find fs in ffi libs.. and its pointing to the dependencies in the root npm not in its own target stuff.. so at least that part is good, but clearly npm as/is is runing fine.. maybe it does more thorough checks, or maybe its because we might have installed ffi globally? though dont really think so.. 
      -- well, seems to be a WELL decried issue w webpack.. we'll see if the possible workarounds mentioned by folk in tickets and stack-overflow work for us
         - aight, so crux of the issue is in https://jlongster.com/Backend-Apps-with-Webpack--Part-I .. basically it looks like webpack tries to bundle all the piles of js as it would for a frontend project, but we have backend/node stuff which makes no sense to bundle for frontend and would fail in bunch of ways regardless when attempted
         - however, the soln there is a little heavy handed, and maybe not necessary for us
         - folk in https://github.com/webpack-contrib/css-loader/issues/447 have a bunch of other lighter/piecemeal solutions, including specifically excluding out particular modules from webpack.. which might be ok.. esp since going by above blog, looks like can quickly find out which ones have a /bin folder and so shoudl be excluded.. e.g. run 'tree -dfin | grep bin' showed we had ffi, ref, node-gyp as expected, but also sshpk, semver, uuid, which, nopt, mkdirp, combined-stream, detect-libc and so on.. not sure if worth dealing w all those
         - anyway, so for now, gonna try quick stuff w ffi/ref/node-gyp that we mention/use, and see if that gets rids of the misleading 'fs' complaint and works out
         - so actual exclusions go into webpack.config.js .. but dammit, didnt work
         - aight, so went w a related but a much simpler setup.. just added module.exports.target = 'node'; in the webpack config file and it was enough to let webpack understand it was for node and get through compilation w/o complaining
      -- except the damn thing when trying to run, now complains 'Could not locate the bindings file' .. goddamit, felt soo close
         - fk, even adding back in the bin file navigating and excluding those from that guys code didnt get rid of it.. fkn hell
         
      -- holy fk it worked!! .. ended up having to go to the bundler location (..target/scala-2.12/scalajs-bundler/main) where the node_modules are, and doing a 'npm install ffi ref' .. and next time it built, completed fine, and when ran didnt puke about bindings etc, dumped out window names !! fkn hell goddamn.. feels almost crazy after all this shit pain.. hope its worthwhile but freakinA!!
         - also a later added note, if regives pain on say webpack dev server stuff, reinstall those, also do npm install --save-dev loglevel, can also consider adding "ffi" -> "^2.3.0", and "loglevel" -> "^1.6.1" to build.sbt as npmDependencies 
      
      - side note.. so basically that part, incl ffi seems to be running from sbts managed node_modules.. so presumably its possibly the way its currently set up, its gonna be pain to get things that are electron specific to work from there.. hoepfully there's not that many.. we'll see
      - hmm, could mean that later we might want to slowly migrate everything from the current setup, where there's an outside node/electron setup that opens up a window, and only the page loading there is from a sjs managed bundle and its node/modules .. to a setup where we basically dont need the outside node/elec anymore.. we'd have to try and install elec to the managed modules, somehow find a way to launch using that, and just reference node/elec apis that way.. else currently, it'll be a pain to try and do anything that needs to leverage electron from the sjs code.. and in particular, among the first things might be global key shortcut handling etc..  anyway, we'll see how far this compromise can go
      
   


03/25/2019 ++ .. micro task notes, as looking at ffi setups etc 

   d- first off, want to find some basic example, get that running again.. the basics w npm etc, getting ui to appear, doesnt need scala/sbt
   d- do a similar, but including win32 api this time.. think there might even be a sample around already.. still just js, write code in js too as need be
      i- setup ffi, some good resources available, 
         - win32 api setup: https://stackoverflow.com/questions/37396157/hiding-other-windows-programs-from-electron-app
            - basically talks about the three cmds required: 'npm install ffi', ' npm install electron-rebuild', ' .\node_modules\.bin\electron-rebuild.cmd'
            - now node-gyp is a global install, so once set up, wont have to deal w again for other similar projects here etc
         - will need to have node-gyp setup: https://github.com/nodejs/node-gyp#installation
      - try and get the window list to work and printable first, just to get that part of w32 api working
      - next, and IMPORTANTLY, make sure can switch windows from there too, as that was an issue before
      - so for testing out switching, doesnt have to be anything fancy, maybe just get a list and switch to the sec one after some minimal input like a btn etc, which should be possible to just copy over from another/prior sample too etc
   d/x- as needed for these steps and further, make clean sub-repos for testing things out.. the switchenator big repo is fine for that, just make sub-folders to try out the various stages of progress... simple electron js app, one w win32api integration, then onto sjs business as appropriate
   - next up, can make a VERY quick stab at making a scalaJs wrapper .. really dont think should be that painful after getting it working in pure node/electron, and again, there shouldbe examples to look up on how to wrap js in scalaJs, and think it looked like it was pretty straightforward
      x- ELSE however, can just consider writing the shit out in js itself.. cant be that bad, literally thousands of ppl seem to be doing it and saying its easy
   i- anyway, only AFTER that, should seriously consider the app specific stuff, and really, if can validate this far, cranking out the app will be a VERY natural, motivating, and satisfying endeavor, at which point wont have to slave drive myself for it step at a time

   d-- work details list
      i- refer to the node-gyp installation page, esp windows part.. the visual studio build tools works well, will install python as well.. took a couple tries, and it might have restarted windows, though not sure.. also better to run those from actual cmd console rather than from conEmu
      i- on that node-gyp page, ignore the parts about the binding.gyp file etc, not required for just this, and creating that file will ask for srcs etc and prevent the electron app from building
      i- the rebuilding of electron (and ffi/electron-rebuild install) only need to be done once.. even for the project itself only need to do 'install' once, after that can just do npm start and should pick up changed code (at least for the simple changes looks like)
      d-- hmm, at some point it was complaining of not finding node-gyp in the right place, after quick look at https://github.com/nodejs/node-gyp/issues/1463, ended up just making a junction at the right place for the installed node-gyp folder (the err wanted things in ..node_modules/node_modules/node-gyp etc)
      
      i-- however, stuff has been pretty flaky despite this.. sometimes the handles get returned 0 for windows instead of the actual hwnd, adn sometimes they dont activate the windows, but at other times it works.. so not clear if its something addressable locally or something else going on
         - and even that guys sample code calls out on that, and gets around by calling the find window way too many times
         - for us though, we just want the listing business, and that seems to be more robust.. maybe wont have to worry about that find bug much
      
   d-- huh, so got the basics of a nodejs thing working, with some pain on getting node-gyp etc working, but interesting side note from there..
      - looks like it was using ShowWindow (instead of SetForegroundWindow), which might not actually have the same restrictions on what it can activate based on the description at https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-showwindow
      - so, if thats the case, then could keep going w what we were doing before w the server/cli w/o having to do the ffi/node-gyp (although prob still should)
      - also, there's more fns that are similar there, incl 'BringWindowToTop' which also looks similar and unconstrained
      - hmm, and btw, just trying out 'SetForegroundWindow' via npm console w/o triggering browser window still works (in contrast to what we had seen w the background java process triggering that), though presumably because the active process then is the node/npm process which is the active process calling for that to happen, which might be all that was required (jsut that a bkg process was prevented from doing so... hmm, nah, think at least once, go it to do SetForegroundWindow even after going around to activate another window after kicking off npm start.. so who knows)
   
   -- anyway, so def an interesting wrinkle and fork in the path on what to do now given this
      - so, first off, maybe gotta fire that old shite back up, and test to see if it actually works if using ShowWindow, and maybe even just to familiarize again
      - in absolute sense, should definitely go w the client-only node soln w node-gyp and ffi.. should be much faster, avoids pointless server/client roundtrip, avoids having a pointless server process/jvm running, and will be a LOT more easily distributable/shareable etc.. 
      - besides, already have the painful ffi/gyp part mostly going, shouldnt be that hard to hack up something usable going from there
      - and can still do almost everything there in sjs anyway, as the issues w getting it up werent to do w sjs
      - and note that a pure sjs/node sln requires no jvm at all, as ofc thats the point of sjs to compile scala to js and run in v8/node along w electron
      - and besides, whether have that stupid srv process or not, gonna be doing almost all the ui etc work in sjs in electron anyway
      - so really, the only possible reason to try out the old srv/cli jvm thing is to just see if using that alt fn it actually works (just for curiosity sake)
      - and maybe, maybe, if run into issues w sjs + ffi/elec then could hash out something quick, but even then will need to keep working w sjs/elec anyway
      
      
   - k, more work details list.. 
      - so now that, for pure js/node, have got the basics mostly covered, can start looking at doing it in scalajs.. shouldnt be too bad
         - also, spending further time in js is counter-productive as figuring out things like array symantics etc is just not worth the effort here
      - aight, so found a npm win32-api .. prob should have looked for it earlier, but either way, could make it easier to deal w stff in sjs.. but first, should try and get that working in regular js itself.. still runs on ffi etc, so all that prior work is useful, just add it, try it, get it working
         - code is at https://github.com/waitingsong/node-win32-api
         - do note that, it too is just a wrapper, and since we dont need much else of win32 other than what we already have, not much more we get out of it
      - next up can try in sjs, though depending on running into issues, might have to go back to basics in sjs and get that working too if win32-api gives issues
      
      -- anyway, so first off, just want to get anything minimal as is running in sjs.. 
         - and there's some fs code there, see if that works
         - then see if can do similar by just adding a very simple js file/package of ours w a simple exported fn, that we want to call from sjs
         - and if so, then can try and do that w the ffi/win32 sample code that we had
         - else, or if desired afterwards, can do the same setup w the npm packages, though really the step wise progress steps above are likelty to be more reliable
         - and at that, we should be good to go if it works.. else if we take the npms path, will have to work more to figure out how to set code to use those
         - although, there's also the thing our sample was from : https://github.com/MrTimcakes/node-hide, and could try to make that work if doing the 'require' w our own version has issues, but really shouldnt be, and ours will be lot more customizable for our needs than pulling that from npm
         
      -- uhh, looking back after a break again.. so quick path list
         - set up some very basic js scripts outside, and make them callable from scalajs
         - so maybe, first up, look up some very basic script file, use that in an elec project in js itself, making it callable/exportable as a module
         - next up, try and use that same w an sjs project calling externally .. prob the biggest step here
         - then upgrade that to use ffi, again make sure can be used from js which should be straightforward, then try and do that from sjs
         - after that, well we're good to go w adapting the actual code we want to do so and testing it out from the elec/sjs proj
         - ooh, and thats mostly it, then we can start cranking out the actual elec app to do what we actually want!.. which will be nice!
         
      -- slight change of plans
         - saw that example of including ext js dependency.. looks pretty straightforward, so maybe just start that way, but dont want ffi complexity to start out with.. soo, set up in sjs, ext js dependency, to do some very basic js lib stuff.. try it out, see if it works, then put ffi, see if it works, and if so, we're off to the real stuff
   

02/15 .. way later thoughts, on possible ui improvement w/ a narrow icons-only side-panel

   - so, its been a while and this has been shelved for a bit, but the nagging thing does keep coming back, esp when doing heavy duty work w lots of switching, and esp since the newer alt-tab-terminator still doesnt seem to be heading in the right direction despite updates, and the usual vistaswitcher seems substantially slower these days for whatever reason upon the hotkey press
   - anyway, ofc since we're hurting for speed, any of this would only be worthwhile doing if the speed of bringing it up would be fast enough, so gotta check that out first before any fancy ui etc work, and ofc the primary functionality stuff still stands of doing the switching w/ foregrnd/bkgrnd app etc
   
   - anyway, so the ui thought was that to have like a side panel
      - with only icons list, and with all of the same apps windows collapsed
      - and when you hover on, will replace the main list of window w just the windows of that particular app
      - and ofc some way of going back to global as well, maybe when you get into area of bar w/o app icons, or a specific header area etc 
      - would be very handy when have piles of interspersed app windows, esp w chrome, explorer, winmerge etc
      - and ofc, can have some key shortcut to switch around those too etc
   

09/29 .. well SHIIIITTT...
   - looks like while the SetForegroundWindow worked reliably from intepreter during testing, it does NOT work when called in a server process!!
   - basically there seem to be a long list of conditions that MS wants enforced before it allows focus stealing, of particular relevance here, when testing from eclipse, the calling process was foreground and/or received last input event, either of which is sufficient for MS to let it bring some other window to front, but for a bkg serving java process, thats not the case and so its failed.. uhh.. they only end up flashing the taskbar for that thing!
   - makes sense on actual straightforward appswitcher apps too, right before they switch they are taking input so its allowable
   - so anyway, not sure what to do next, could possibly impl the damn thing completely in electron/node w/ some mix of sjs/js and ffi etc, but will be a pain, and not sure how worthwhile it woudl be

09/29 .. aright, so on to adding some actual functionality..

   - so, general functionality in brief : 
      - need backend to query for tasks, compile up into prob json, send over to client, thats it
      - and for frontend, parse that json, display basic list, add scroll/click fn, register hotkey, make window hidden/viz, add sorting, add searching
      
   - much later thoughts / optimization etc, but ONLY to keep in mind while focusing on immdt progress work etc
      - want some speedup, so prob want to have decent cache on FE, and all icon loading etc should be directly on FE ofc
      - prob also means, eventually might not want directly bknd querying on call, but something like bkg updates etc, but not clear how worthwhile that would be, or what would be the fastest way (tick queries, websocket etc), or if thats too resource intensive, or lead to more frequent crashes
      - if early issues seen w jna calls for winamp monitor continue, then on long running, the jna jvm might be crashing, in which case might need more resilient design w a monitor jvm process and supervised/replaceable jvm for actual jna work.. but meh we'll see
      
   - for starters, should hash out the backend part, shouldnt be bad, and can just print out on api call, the json part should be quick too
   - possibly could look at adding the rev api too, to activate something, just to get it over w and usable via api, but prob really not needed for a bit
      - also prob means, for fidelity across changes, that'd prob require actually passing around actual window ids etc
   - and the calling can be directly done when switchenator is invoked, dont worry about lag/speeds etc there for now
   
   - then setup very basic parsing on elec frontend just to print out the list, (just titles is prob fine, later can add exe path, icons etc)
   - should prob add a bknd call right after that to actually allow switching.. on FE, can be on simple click handling (or maybe kbd) etc
   - that'd be pretty minimally usable by then, so should start looking at global hotkey reg to call that up, still dont need to worry about hiding window
   - then can look at reading and showing the icons as thatd be important for usability.. can cache those up for speed
   - then should add sort handling prob, as that prob adds the most immdt value
   - then prob getting win to hide on action (along w showing on hotkey) might be worthwhile, though really, both could prob be skipped, esp the hiding
   - further out, should add the partial-match search ui.. itll be useful, but not something I find wishing for, esp once I'd have sorting/grouping
   - at some point can look at ui prettiness etc.. window locations, menu bars, title bars, bkg, scrolling, maybe even bknd configs!
   - way way down the road could consider packaging into installer etc, but really think might be fine just as is in dev mode potentially forever


09/29 .. operational minimal shell .. reference notes
   -- so, leveraging the setups for nuncer/airenator and the eary shell for airenator nunce sjse app, this was thrown together quickly
   - note that this skeleton was mostly made by copying/deleting/modifying from those mentioned projects, might be some leftovers to clear out still
   - basically consists of a backend (switchback) and electron geared frontend (switchface)
   - for now, keeping them mostly separate, could consider doing some shared business later
   - nevertheless, modeled the structure after nuncer which has a similar single sbt built server/client/shared design, so can add shared stuff later
   - switchback runs on basic straigtforward scalatra, currently just a shell, not planning on pushing any UI stuff unlike for nuncer, just strict API stuff
   - switchface client, looks like a regular scala-js frontend, but with minor tweaks to target for electron running
   - in particular, in main build.sbt, a 'elPack' task takes sjs outputs and massages/copies them to a electron target location
   - a simple npm/electron package.json looks at the location and runs the app (when calling npm start), with hot reload when things there change!
   - and with separate live targets in build.sbt for both server and client code, can have changed to server code auto picked up and deployed to server, client code auto picked and compiled to sjs and moved to electron folder, then npm/electron auto reload the client frontend.. its nice!
      - although do note that the reloading part happens on global change, so any code change will trigger both server and client to rebuild/redeploy, but prob is bearable, and certainly so for this particular proj w/o much internal state
      - and realistically, once backend stabilizes, as its straight forward, might end up doing that w/o hot reload when just working on the client

   
09/29/2018 .. SO IT BEGINS !!

   -- so, the motivation and bkg for this came together quickly, and might be ephemeral, but quick progress has been made, and giving it independent life here
   - anyway, so some more on details and bkg are copied over from elsewhere below, but mostly for historical reasons   
   
   -- PRIOR THOUGHTS HISTORY :
   
      - so instead of doing bunch of pointless recap on more background, copying here some of the relevant notes from elsewhere (running notes dump etc) on what/how and how it progressed to this initial proj as of 09/29
      - basically, was getting annoyed at not being able to sort through task-items in vistaswitcher, and switcheroo though it has search, being worse in most all other areas, so thought was hell, maybe should just try and throw together something quick, esp given the last exploration w java JNA that seemed to work easy and mostly ok, though w questionable stability on long runs
      - initial thoughts were on scalafx etc, but recently had also become aware of electron based 'native' 'webapp' like apps, and though a poor fit here, esp considering the round about manner and pointless memory waste for such a simple and close to native app, was a good excuse to learn it / try it out, and seemed to be easy enough to hack together, so decided to get it going
      - (for context, was also around the same time, had some ui building for 'airenator' in back plate, so kinda of picked it up for both, as although the airenator frontend wouldnt need electron or need to be native, figured might not be much more effort to write the FE in electron rather than just as a webapp anyway, so why not!)

      09/12 .. switcheroo gripes list
         - uhh, really wanted something thatd let me see task list entries sorted by app/type etc, and decided to give a good shot back to switcheroo
         - on plus side, it could be made decent, and might even be something I can update/customize in code if I want, its up in github
         -- on the gripes.. man its nowhere near as ready/usable   
         - freaking scroll scrolls the window instead of scrolling through entries there
         - the hotkey on repressing escapes out of the window instead of doing next like alt-tab's tab, or vistaswitcher's key would 
            - although that seems to work in alt-tab mode, so prob could open a ticket and might be fixable quick
         - and that prob also is why it doesnt actually activate any of the items on single-click, have to double click, how dumb is that, esp since there's nothing there to do on 'select' anyway as there isnt even any right click on the items.. uhh just dumb
         - why is so dog freaking slow!, even the dumb list filtering.. doesnt have to be that slow
         - and ofc, the option to sort by type, or really the option for anything(!) doesnt exist yet   
            - although what would be nice woudl be to add keys like alt-s or alt-g etc to enable that
         - and the devs dont seem particularly updating it either, so its upto me to do it if I want it, though could see if by putting up issue anyone else might be interested to try out or help
         
         - so, could a thought be to instead of trying to hack into that etc, just pull up something like scala-fx and try to build a simple quick thing in it itself? i mean, w jna etc, actual dealing w windows etc seems straightforward
            - though might need to dig just a bit more at getting icons etc
               - def do more search, but options are def available.. e.g: https://stackoverflow.com/questions/19279134/java-windows-taskbar-using-jna-how-do-i-convert-window-icons-hicon-to-java
            - also only tangential, but there's an interesting https://github.com/dorkbox/SystemTray if that feels worthwhile later
         
      09/12 .. hmm following on from the task-list ui, maybe consider for others too
         - might be interesting if doing some/any java-fx work on that app-switcher thought, to maybe just try a hand at scala-fx or whatever the picked soln is for some other quick and dirty stuff too
         - for instance, making one for airenator might not be a bad idea.. 
            - now ofc, really would prob be best suited for a regular web client work, but eh, if want practice, sure maybe
         - although tbh, any 'practice' should really just be done on the switcher app itself, thats perfectly fine for it and actually has immdt use, as well as not being doable even remotely passably in webapp format, so makes it worthwhile.. everything else is perfectly fine as a web app

      09/26 Wed .. heading deep into electron quick apps .. (got through weekend, w gb working, should be plenty of time to get these cranked out!)
         - prob can stall work for a bit w/o imp stuff, maybe create some ticks and put up ws test code, talk about TPS/AP/travel etc through weekend
         - on scalaJs-electron work, maybe crank out airenator first, or realistically could do both simultaneously, should be similar
         d- first get the quickstart samples from git working
         - then build a similar proj structure somewhere, might be easiest on airenator repo
            - update it to have it minimally bringing up a window, sending some quick cmds from btns that can be seen to work in airenator console
            - update airenator core code/api to return full state in json, basically for each call.. might be the easiest to quickly patch up
            - hook up the sjs-e app to consume the airenator json output and have a ui that shows cur state and minimal input to send back in.. thats it!
         - then can move on w hashing out switchenator(?) quickly
            - use similar quickstart skeleton, incl both the backend/frontend parts
            - hack up a quick backend that gives full json output on query, thats all should be needed, dont worry about speedups/optimizing etc for now
            - on client, set up simple listing first of processes, later can add icon disp w icon caching, 
            - then add up kbd hooks for scroll, click, Alt/Enter press etc, impl grouping, impl searching.. thats pretty much it!
   
   


