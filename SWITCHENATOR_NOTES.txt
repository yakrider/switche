
RUNNING NOTES DUMP ON POSSIBLE WORK ON THE SWITCHENATOR PROJECT :


04/28 + .. note on perf after getting to a mostly working state
   - so, we have a mostly usable working test setup now, lists all the windows, does activation, allows grouping by task, decent ui, fetches/loads icons too!
   - and its not too slow either, esp after the initial app startup once it gets most things cached..
   - so def dont need to redo it etc.. but had some interesting revelations as I've been looking at perf and the initial load time..
   
   - so, the bkg queries take some pieces of time, esp the first win query, there's also fetching icons etc, but those are indiv actually not that slow
   - and we were using the requestAnimationFrame feature so things could be timed w when browser wants to do rendering updates
   - it looked like despite those, at least when making frequent rendering requests, the thing actually was quite slow (was fixed a bit by bunching render reqs)
   - essentially, two shit things happenend.. because we wanted to jump on the requestAnimationFrame, the code got written to queue those calls on state change, and on render call, to actually re-render the whole freaking page again! .. that sucks, esp w all the scalatags indirection, plus just inlined icon images!
   - it does make code easier, but if we were doing our old usual stuff, we'd have kept handles on parts of the dom internally as we created them, and just updated those instead.. which would have been way faster whether we used requestAnimationFrame or not, although ofc we'd have to do that management ourselves
   
   - now, its not clear if its gonna be worth rewriting that part where instead of rendering everything, we just try adn update the changed elems
      - in particular, would mean keep array of entry elems, update when we have title changes or icons come in etc, or when grp/ungrp happens and so on
      - would also need to figure out ordering logic if dont want to re-render.. which could be thorny..
         - say a refresh happens, and couple entries moved up/down in the list.. not gonna be trivial to monkey-patch the dom, although could be done, by say walking on the old and new list, noting moved vs new/removed, then doing inserts and deletes as needed.. but prob a pain not worth the hassle
         - alt, if could have the elems created but not displayed, and browser is efficient when just 'placing' them somewhere as opposed to rebuild, could consider
         - and just noting, that if so, then doing similar w icon images would be good too, as there's bunch of inline copies
         
   - so, w that in mind, one way of looking at what we did, is we acted like there was a virtual-dom while there wasnt.. in theory if we were using react, then we'd make the new page, react would calc the changed components etc and render just those parts.. that'd make it similar to our element caching solution, but w/o us having to do all that complexity, and prob w bunch other optimizations they do at their ends
   - but, obv def prob not worthwhile trying to rewrite this in react.. esp at this point, though maybe should really have considered that before starting
   - eitherway, its a good reminder to pick up on that before starting something like this again, and hence noting here for future reference/reminder.


04/25 + .. taking stock and immediate paths forward

   d- having gotten past the massive initial winapi blockage, a huge amount of progress has been made, though new issues do keep surfacing..
   d-- have a minimally working setup, w actual listing and switching working!
   d- took a bit to get at the flakiness on activation, but activating after a tiny timeout to let win register the app did proces last input helped a lot!
   d- ended up working a bit on the ui/presentation .. and its already not bad.. thats nice!
   d- some very decent caching and call optimization has been built in.. gotta say its not bad at all speed wise, after the first startup
   d- getting at the exe has been a pain that still needs addressing.. the getWindowModuleFile was a red herring.. only works for windows of same exe process!
   - ugh the webpack dev server didnt look like would pan out either, its built into sjs, and doesnt play well w electron
      
   -- next up sets of things to focus on:
   
   -- impl internals   
   d- def gotta get that exe extraction working.. not least because we wanted that for all of exclusion filtering, ico extraction, grouping/sorting!
   - really want to work on the icon work too, but maybe can wait and see how far just the exe names can get us, though feels it might be crucial for usability
   
   -- new functionality over vswitch
   d- think we're already actually faster than vswitch given all the caching, esp for anything after first invocation.. its awesome!
   - the first key improvements ofc, would be sort by app mechanism.. gotta put than in earlier rather than later!
   - and soon after, want to start on a find-as-you-type search.. right in there, maybe w a box on ribbon.. would be nice
   
   - later could think of less missed enhancements.. say considering adding a close mechanism, say via middle click, or an icon on hover, context menu etc
   - might be too much, but could consider what it would take to do selective preview.. say when holding onto something.. would be useful for windows w tabs
   - way way later, could revisit that thought on making an exension for chrome that could feed this tab info data.. but w TabOutiner around.. prob not worthwhile

   -- ui work
   - need to start putting in at least some minimal keyboard handling.. even if just inside page for now.. for sorts, search, grouping etc
   - gotta add in the outside hotkey handling for the elec app too, just to get the thing to show up on hotkey, and maybe hide/reappear too
   - need to get mouse scrolls working better too, as think the scroll on elems w mouse as in vswitch works better than just having to always point to stuff
   - should revisit unicode char display.. dont seem to be working despite making calls to winapi unicode fns.. prob something w electron or html page encoding
   
   -- misc setups
   - and really at some point, gotta try and merge in the two nested electron setups for this into just the sjs ele.. though might not be easy/worthwhile yet
   - same w trying to get webpack/hot-reload working, but given already tried the ovious stuff, and its a tradeoff w actual dev. and it gets less useful further along, will have to see how much it still makes sense as a bunch of the early dev gets completed
   

04/~26 .. about that icon display stuff
   - so actually writing this following up on tasklists above.. that icon display actually seems surprisingly involved
   - so there does seem to be a guy's effort to take a stab at it, and its decent too.. 
      - https://www.npmjs.com/package/icon-extractor .. http://sciencevikinglabs.com/icon-extractor/ .. https://github.com/ScienceVikings/IconExtractor
   - however, that too goes about the round about way of using a c process to extract the icon the tx over to node as base64
   - but could be a pain integrating that c included project.. although could also be straightforward, so prob def should try it out via npm quick first
   - but if its any pain, been considering why not just do it offline.. for personal use for myself might not be that big a deal, and could be lot quicker to have it
      - basically, on switche side, keep an updated running set in disk of all exes seen so far
      - and have it check some other config file to see if there's matching icons for those to load from some given location, and if so to do it
      - offline, we could use some other seprate utility to extract icons for exes, maybe based on switche's list, or proactively at first too, and save them
      - thats it, would make it way straightforward to get it running, and keep all that shit complexity out of the node/elec project
      - and def there's piles of utilities to extract icons from exes, incl standalone tools, as well as java libs if so desired
   - well hot damn, tried the icon extractor.. and a little bit of fiddling around w translating around js data vs sjs etc.. but it freaking mostly works!
      - and the base64 icons appear to not be all that big to be a pain either.. its nice!
      - now the code's a lil messy w global pseudo registered callbacks etc, but damn that was lot easier than how it could have panned out!
      - note that in sjs node, it installed the reqs when the updated build.sbt was reloaded and webpack ran, but since ours is running from an outside electron/node, had to install it there manually for it to be found I think, but given the murkiness of many things breaking/fixing together, who knows


04/23 .. moving these impl notes from code to here, as they are quickly getting outdated, but could be useful for thought-evolution reference..
   -- some thoughts on rules..
      - note that it might be easier to explore these using jna code from the initial switchback project
   - not sure if all things with empty titles can be ignored.. but maybe ok to start out with
   ?- but most things w len/width 0 windows can be ignored, and most, but not all, have empty titles..
      ?- meaning checking title can be an initial shortcut, but if find empty, can go ahead and check win sizes
   - looks like there's 'Desktop' window named 'Program Manager' usually at bottom of stack, not sure if should exclude it
   - there'll be a bunch of other spurious windows explorer windows.. looks like filtering for empty title should clar most/all of those
   - some w hidden windows should always be ignored.. like our own ShakenMouseEnlarger.exe
   - most things from ApplicationFrameHost.exe can prob be ignored
      - especially if they have dup titles w some other windows thing (e.g. Store, Settings)
   - winamp seems to give two windows too, size wise looks like one is for the titlebar-only/windowshade mode.. but doesnt matter which one we keep
   
   -- so anyway, will need some mix of generic and specific rules
      - abstract rule by exe .. specific instantiation for ShakenMouseEnlarger
      - generic rule for empty titles
      - abstract rule by exe/title .. specific inst for explorer 'DesktopWindow'
      - abstract combined rule .. specific inst (dup ApplicationFrameHost), inst (dup winamp)
         - e.g. chained AND rule w/ a generic is dup title, and inst of check exe, maybe even check exe of other dup
         
   - hopefully can avoid having to read win sizes etc.. likely to slow things down etc
   - hopefully dont have to rely on list order either (e.g. that ShakenMouseEnlarger/Start are at top, and the desktop is at bottom
   
   -- as for actual processing strategy..
      -- we want to make approx presentation fast, then increase accuracy as we go along
      - display pre-existing render immediately
      - then maka a EnumWindows call w streaming callbacks w just hwnds
      - have callback handlers (atomically? no, js is single-threaded!) update an ordering holder, or update a new one per winlist call
      - on each callback, check if hwnd already in cache, if so update display w it in right position
         - if not in cache, fire off call for isVis and get Title checks, when those are back, update cache
         - given results, if meet inclusion criteria, update/reorder display, if need more info queue more calls (e.g exe loc)
         - ditto w handling any further calls make async like w results from exe loc lookup
      - for the ones in cache, and now displayed, still fire off lookups, as will want updated title at least
      - as things come back, stuff that doesnt come up shoudl move lower and lower in queue, should prob put a timeout to remove them after some time
         - could also explicitly queue a check for isWindow before removing the ones that dont come back.. not clear if should leave those in cache
         
      - also, since all this might (hopefully) be really fast, and its pointless redoing layout repeatedly w/o display, should call requestAnimationFrame(cb)
         - will let us naively continue making page updates on any winapi callback, while the re-render only happens right when chrome is about to repaint (~16.6ms)
         - also, its just a one time request that get collated till next paint, so everytime we get win callback that precipitates a change, queue it up, thats it
   
       

04/21 ++ .. post minimal workable path notes ..
   
   - k, so, dates above might be deceiving, but finally got done through the last part of getting basic win-api working via ffi in an electron hosted node app, all of which makes most of the second half of the long note below.. but anyway now that the minimal mechanism is validated, although more can be done there, can start thinking about what exactly is next on going about shaping things here quickly
   
   - so first off, there's still that disconnect thing going on w electron launcher/host, and the frontend like sjs bundler connected to the index.html that gets loaded into the electron page.. not that big a deal since still can get pretty much full access to node stuff from the sbt/bundler managed part, but at least as of now, that isnt doing anything electron.. eventually could look into seeing if can eliminate the external stuff jsut to fire up electron
   
   - also note that, the bundler when its trying to look up stuff, 
   
   - eitherway, as it stands, among the few things we'd prob want electron functionality is in registering a global shortcut.. 
      - now ofc its quick and easy to do that in js, and examples are straightforward (https://electronjs.org/docs/api/global-shortcut)
      - if so, we'd have to pass those events into the page.. and currently we dont have very good comm between those.. 
      - presumably we could do so by making the bundler compile not just as an app, but as app+library 
         (https://scalacenter.github.io/scalajs-bundler/reference.html#bundling-mode-library-and-application)
      - then could just call the desired sjs fns from js code as necessary, as should be able to import the bundle js in any js code just like in index.htm
      
   - would prob also want to update the window to be more reasonable, but for now prob nbd, might as well keep going till more usable
   
   d-- def first in line for functionality testing, is to make sure that can do activations as well, otherwise, kind of pointless !!
      d- oh yeah.. shit def works! .. freaking feels nice man, to finally get to this point after unending stream of frustrations!
      
   - next up, is getting the list of windows, and minimally at least, the hwnd, back to scala via return val rather than printing in console
   - the other half on making the make-fgnd by passing hwnd should be even easier
   - then can have a minimal ui w printed out the titles in ui as links, and having them clicked to activate the window!!
   
   - hmm, although given we're this far, and know how things work a lot better.. could be worthwhile to try and see if we can do the win-api directly in our code..
      - basically to make facades directly using ffi, and use that as npm dependencies for bundler.. making facades should be that bad
      - and further, it will give MUCH better control and easier iteration to make things fast like 
         - e.g. calling get window fns w callbacks to update dynamically, 
      --  impl notes on this
         - to pass around callbacks etc, worth looking at http://www.scala-js.org/doc/interoperability/types.html
   
   - and then can quickly start iterating on usability, as all that is just sjs stuff that can be done w/o much pain! 
   
   - and while doing the sjs ui stuff, should REALLY look into the 'webpack-dev-server' as that would save good time and annoyance on code/build/test cycle
      - https://scalacenter.github.io/scalajs-bundler/cookbook.html#webpack-dev-server
      
   - and then ofc, lets start eating eating our own dogfood.. sooner the better!
   
   - hmm, and will have to figure out what makes sense for bkg tasks etc.. basically doing periodic polling to keep querying data etc
      - esp if looks like we'll be stuck waiting for winapi calls in any thread etc, def gotta figure out async kind of work to have things be snappy
      
   - ugh, and there's work to get icons etc, even just to have minimally usable stuff, not gonna be handy to use w/o visual guidance on apps etc
   - and ofc, gotta see what makes most sense to querying the details other than just the title etc for the windows.. 
      - want enough at least to be able to group by exe, filter out stuff, lookup icons, etc .. and hopefully keep it fast and/or cached
   


04/05 ++ .. another dive-in

   - aight, so the last one sputtered out, w the sjs setup just not working to get ext js modules working at all, let alone getting to try out ffi
      - but saw that maybe there were improvements in latest sjs versions to make that a bit easier, though all the material etc we've based shit on is from older versions and just trying to ram it through just wasnt working
   - so now, gonna try and restart the process from a bit more grounds up fashion..
      d- first take the more recent sjs tutorial etc to build up a clean skeleton project in sjs/node .. no electron, no ffi, no x-proj deps etc
      d- try and get basic js import/require working there, and if so, can see where to go from there
      - (and on plus side, might get us much better situated to be able to deal w electron, ffi etc incorporation going forward too, having understood better from the grounds up how the integration etc ends up happening
      
   - more concrete, start w basic tutorial, try out import, if really get stuck, can ask guys in gitter for samples/pointer/link to get that working
   
   - ok, so for more concrete stuff on what exactly the sjs 1.0.x.Mx milestone versions vs 0.6.* versions, here's the starting point
      - https://www.scala-js.org/news/2017/07/03/announcing-scalajs-1.0.0-M1/
      - think biggest stuff was about moving core dependencies out etc, so prob wont be too bad other than code reorg and so on
      - and uh, best of all, the 1.0.x.Mx path explicitly is setup to deal with js globals such that the nodejs 'require' works nicely.. hmm
         - although realistically, that only ensures the require, to use from sjs, still need facade etc, at which point, as it suggests, should just use the usual suggested mechanism of '@JSImport and/or CommonJSModule', and create a simple facade for the calls
      
   - finer grained log/notes
      - lots of shit w things that break from default tutorial at https://www.scala-js.org/doc/tutorial/basic/
      - so instead refer to https://github.com/scala-js/scalajs-tutorial which seems to be more recently maintained
         --> but make sure to be on the 1.x branch of it!!
         
      - next up gotta look up the sjs bundler that interfaces better w npm packaging etc, though for us, could also go the ProvidedJS route
      - sjs-bundler also has links to examples for writing simple facades to js! sounds like exactly what we wanted!
         - https://scalacenter.github.io/scalajs-bundler/getting-started.html
         - maybe could actually try that, but w/o the sjs bundler, i.e just w the local js (via ProvidedJS) and a facade for it
         - also noting that a facade in sjs for js module/file is not that different from a facade for winapi via ffi in js itself (which we did/verified earlier)
      - as for doing both sjs bundler (for npm dependencies/facades) and provided-js, there's some links here on how that could be made to work
         - https://github.com/scalacenter/scalajs-bundler/issues/190
         - and really, think the bunder is the way things are moving forward, and the rec for 1.0+, so should try and go w that unless get stuck there
      - note ofc, that if bundler works well but provided-js becomes a pain, could also just try to go by some win-api npm package that think we've run into before as well etc, and if necessary write facades for those which dont seem too bad.. although being able to do local stuff will def be handy
      - also, the bundler has a nice cookbook, which, at this time, will be the most up to date, and give good broad instincts too.. should really go w that
         - https://scalacenter.github.io/scalajs-bundler/cookbook.html
      - ooh, also note that there seems to be at least one skeleton for sjs/electron w the webpack/bundler branch !
         - https://github.com/massung/scala-js-skeleton.g8/tree/webpack
      - there's also a footnote on packaging for electron w bundler merged into some tree of that cookbook, not sure why its not (at least currently) in trunk
         - https://github.com/scalacenter/scalajs-bundler/blob/4e121bfb1aeb743af500887635bd723c183979a4/manual/src/ornate/cookbook.md
      - on setting up actual JSImport schemes, this link should help get the basic idea
         - https://www.scala-js.org/doc/interoperability/facade-types.html#import
         
      -- sweet, so using simple file position import, ext calling seems to work! thats awesome.. gonna get that committteddd!
         - hmm, so wonder if its worthwhile trying out simple ffi based stuff now..
         - nah, should go to elec based stuff and try and get local import working there first.. that'd go a long way to getting us set up
         
   -- so, 04/07 here's a checklist on various partial stagest to getting there (i.e to sjs + js-local-imports + electron + win32 ffi)
         d- 0.0.1 - js, js-loc
         d- 0.0.2 - js, js-loc-ffi-w32
         d- 0.0.3 - js, js-loc-ffi-w32, elec (elec-win32-test)
         d- 0.1.1 - sjs, sjs-js-loc (sjs-node-ext-module-test)
         d- 0.1.11  sjs, sjs-elec, js-loc (sjs-elec-local-js-test, others) .. note that its sjse + js-loc so far NOT sjs-js-loc
         d- 0.1.12  sjs, sjs-elec, sjs-loc (sjs-elec-local-js-test, others) .. aight, direct path works apparently for JSImport, will have to see if ok for ffi too
         ?- 0.1.2 - sjs, sjs-js-loc, sjs-elec
         ?- 0.1.3 - sjs, sjs-js-loc, js-ffi-w32
         ?- 0.1.4 - sjs, sjs-js-loc, js-ffiw32, sjs-elec
      - so given we've finally gotten 0.1.1 (sjs + js-local) working, q is do +sjs-elec or +ffi next
         - think def should do sjs-elec next, as might be able to do ffi just from js, as ffi parts are only called from js imports
         
   - so starting w the sjse-elec test.. doing a separate build since the old one is a xapp, and older versions
      - ended up buidling from 'sbt new massung/scala-js-skeleton.g8 -b webpack'  (i.e. from that github repo webpack branch)
      - fk, those dont work w 1.0.x milestones.. for now going down to 0.6.27.. will see how that pans out
      -- uhh, that shit also has weird setup, not even clear how the electron shit actually gets integrated into sjs.. gonna be a pain.. 
      
   - fk, trying back now on sjse-xapp.. we have some more insight from the js-elec-w32 app tests, maybe can leverage that to get the old sjse app working now
      - dammit, even w fkn around, looks like there's incompatibility between using the scalaJSLinkerConfig for module import (as used for local module import) which makes it not work w jsDependencies, and how the electron app structure was
      - suggested soln is to try adn figure out how to use scalajs-bundler w that shit.. prob means should go back to the non-elec version and get that working w/o the scalaJSLinkerConfig? (ref : up top at https://www.scala-js.org/doc/project/module.html)
      --> so, the old sjse format uses the jsDependencies in sbt crap, and thats not gonna work w JSImports, so maybe this isnt worthwhile anyway, and gotta go back and revisit the massung version and see if can set that up for easier electron use then instead?
         - and while at it, could first try the inclusions to make sure those work (say from console) before dealing w actual electron crap
      -- wait a sec, the working sjs-node-ext-module-test still doesnt use bundler, and uses scalaJSLinkerConfig and Imports..
         - so should be able to get working w that for sjse (hopefully letting jsDependencies in sbt do all but local shit)
         
   - goddamn, so gonna start a clean 'sjse-quickstart', just to get to a point w working elec again, and w/o any of the cross-proj bs.. then can move on from there
      - uhh fk .. feel like was close, but now appears we need to be on 1.x versions, while the only thing the dumb mscharley facades available are way old
      x- hmm, coudl try adn force use whatever dependencies are available and see if that works out
         - nope, shit be pain in the ass
      - or could try and just copy over the facades and keep em around for local use
         - well, brought over the dep files, tried to compile, copmlains of @JSExportDescendentObjects annotation, orig being in sjs 0.6.9 and sbt 0.13.9
      --> fkn sob, this stupid shit, after all this, getting this to compile. upgrading all of those dumb elec facades to work w sjs 1.x , and STILL gives the fkn error saying cant find the modules.. un fkn believable
     
   -- 04/21+   
   -- k, so at this point, think it might make most sense to go back to that massung 'sjse-elec-local-js-test' which was already set for webpack, and try and see if can just get that to print/play nicely on electron launch.. shouldnt actually be that bad if its all setup, and since we're now quite familiar w how the launches etc work there too.. prob our best bet.. and maybe if that works, but we want to come back to our setups, it might give clues on whats needed to get things to work w webpack too   
      - fkn shit, that thing, while it comes up (note to use fastOptJS::webpack instead, and checkout the webpack branch), it doesnt really seem to have the electron and regular sjs/js/html parts connected.. whatever the 'left as exercise for reader' part is, is fkn infuriating... i tried a bit, but really prob not worth fkn around w something that the guy didnt even try out.. who know if its straightforward or just stuck up in painful shit
      - (do note that, on trying to build w webpack, it complains of a bunch of shit and assertion failures, but does seem to create the right js bundles!)
      - and besides, it has no/minimal elec support for sjs.. its all in js mostly.. so even if get it working prob a continuing pain in the ass
      - the minimal sjs connection though, is there.. i.e. the bundle calls its 'main' in scala, and that executes and prints in console, just the elec part sucks
      -- ugh, turned out the simple integration just required that the div i'm trying to pullin main code was defined in html before the bundled script was included.. dammit that sucked!.. anyway, we'll see if this is an adequate way (elec integration but more like a page call), but at least we can move ahead from this part.. the stuff below about trying to make use of local js though still applies 
   
   -- ok, here's a round about thought.. so the pain w that massung webpack version was connecting w elec.. but why care about that, we have other mostly working samples for that part.. the missing stuff there was trying to get the sjs w elec to load up local js stuff right.. and that was what we were trying to get to by using the webpack bundling shit for our sjs compilation.. until we got stuck wasting time on that template's elec setup...
      - so first thought from there would be to try and take the bundling setup from there onto other working sjse setups.. and thats not a bad idea
      - however, for that to even be worthwhile, we should def test out that w the bundling setup, we actually can indeed use local js stuff!!
      - and that could be tested out just from console w/o elec shit, so should get that figured out and tested first before trying to take that over to other sjse!!
      
   - well damn, that webpack stuff does seem to pick up local JSImports and its prob doable to run w it the whole way.. now just gotta make sure ffi works too
      - man, havent even looked at ffi in a LOONG while.. we'll have to see if we can brush up quickly looking up old working shit.. glad had separate samples!
      - wish there was more stuff on that I had written down below than seems to exist.. fk.. think beyond just requiring/installing ffi, it reuqired for electron to be rebuilt, likely using the electron-rebuild in dev-dep, and that in turn might need the node-gyp.. and basically that the app will ONLY work with such a recompiled electron.. now if desperate, could try copying over that electron/node_depencies tree over, but that seems bone-headed.. should try and get this working, then diligently note things down to make it easy to follow through when inevitably will run into it again
      
   - aight, so starting w direct ffi from node (same as in elec-w32-test, but now for sjs-elec-local-js-test), will later try for its sjs node_modules
      - so just to see, tried to just add the dependencies to package.json and install/run .. the install actually called a node-gyp rebuild.. which despite complaints, esp about not seeing a binding.cc, seemed to eventually finish w all the c stuff, realistically though, think it only did the ffi build, nothing for electron itself.. either way, when trying to run it fails complaining about dll binding etc
      - so now, trying to do an actual electron rebuild.. looking up at that reference again.. its below.. basically three cmds
         - 'npm install ffi', ' npm install electron-rebuild', ' .\node_modules\.bin\electron-rebuild.cmd'
      - the node-gyp was installed globally previously, and so not needed again
      - and thats it for this! .. after that w the copied over win-api ffi code, printed out the list of active windows !!
         
   - alright, now there's one big hurdle left.. trying to get that to actually be usable from electron
      - first blush, since its local, gonna try and see if can just move that to local file, and hopefully not have to install any of the shit into sbt's own version of 'node_dependencies' that its compiling up to later put into webpack bundle.. fk we'll see
      - huh, interesting, on quick attempt, sbt webpack fails saying it cant find fs in ffi libs.. and its pointing to the dependencies in the root npm not in its own target stuff.. so at least that part is good, but clearly npm as/is is runing fine.. maybe it does more thorough checks, or maybe its because we might have installed ffi globally? though dont really think so.. 
      -- well, seems to be a WELL decried issue w webpack.. we'll see if the possible workarounds mentioned by folk in tickets and stack-overflow work for us
         - aight, so crux of the issue is in https://jlongster.com/Backend-Apps-with-Webpack--Part-I .. basically it looks like webpack tries to bundle all the piles of js as it would for a frontend project, but we have backend/node stuff which makes no sense to bundle for frontend and would fail in bunch of ways regardless when attempted
         - however, the soln there is a little heavy handed, and maybe not necessary for us
         - folk in https://github.com/webpack-contrib/css-loader/issues/447 have a bunch of other lighter/piecemeal solutions, including specifically excluding out particular modules from webpack.. which might be ok.. esp since going by above blog, looks like can quickly find out which ones have a /bin folder and so shoudl be excluded.. e.g. run 'tree -dfin | grep bin' showed we had ffi, ref, node-gyp as expected, but also sshpk, semver, uuid, which, nopt, mkdirp, combined-stream, detect-libc and so on.. not sure if worth dealing w all those
         - anyway, so for now, gonna try quick stuff w ffi/ref/node-gyp that we mention/use, and see if that gets rids of the misleading 'fs' complaint and works out
         - so actual exclusions go into webpack.config.js .. but dammit, didnt work
         - aight, so went w a related but a much simpler setup.. just added module.exports.target = 'node'; in the webpack config file and it was enough to let webpack understand it was for node and get through compilation w/o complaining
      -- except the damn thing when trying to run, now complains 'Could not locate the bindings file' .. goddamit, felt soo close
         - fk, even adding back in the bin file navigating and excluding those from that guys code didnt get rid of it.. fkn hell
         
      -- holy fk it worked!! .. ended up having to go to the bundler location (..target/scala-2.12/scalajs-bundler/main) where the node_modules are, and doing a 'npm install ffi ref' .. and next time it built, completed fine, and when ran didnt puke about bindings etc, dumped out window names !! fkn hell goddamn.. feels almost crazy after all this shit pain.. hope its worthwhile but freakinA!!
         - also a later added note, if regives pain on say webpack dev server stuff, reinstall those, also do npm install --save-dev loglevel, can also consider adding "ffi" -> "^2.3.0", and "loglevel" -> "^1.6.1" to build.sbt as npmDependencies 
      
      - side note.. so basically that part, incl ffi seems to be running from sbts managed node_modules.. so presumably its possibly the way its currently set up, its gonna be pain to get things that are electron specific to work from there.. hoepfully there's not that many.. we'll see
      - hmm, could mean that later we might want to slowly migrate everything from the current setup, where there's an outside node/electron setup that opens up a window, and only the page loading there is from a sjs managed bundle and its node/modules .. to a setup where we basically dont need the outside node/elec anymore.. we'd have to try and install elec to the managed modules, somehow find a way to launch using that, and just reference node/elec apis that way.. else currently, it'll be a pain to try and do anything that needs to leverage electron from the sjs code.. and in particular, among the first things might be global key shortcut handling etc..  anyway, we'll see how far this compromise can go
      
   


03/25/2019 ++ .. micro task notes, as looking at ffi setups etc 

   d- first off, want to find some basic example, get that running again.. the basics w npm etc, getting ui to appear, doesnt need scala/sbt
   d- do a similar, but including win32 api this time.. think there might even be a sample around already.. still just js, write code in js too as need be
      i- setup ffi, some good resources available, 
         - win32 api setup: https://stackoverflow.com/questions/37396157/hiding-other-windows-programs-from-electron-app
            - basically talks about the three cmds required: 'npm install ffi', ' npm install electron-rebuild', ' .\node_modules\.bin\electron-rebuild.cmd'
            - now node-gyp is a global install, so once set up, wont have to deal w again for other similar projects here etc
         - will need to have node-gyp setup: https://github.com/nodejs/node-gyp#installation
      - try and get the window list to work and printable first, just to get that part of w32 api working
      - next, and IMPORTANTLY, make sure can switch windows from there too, as that was an issue before
      - so for testing out switching, doesnt have to be anything fancy, maybe just get a list and switch to the sec one after some minimal input like a btn etc, which should be possible to just copy over from another/prior sample too etc
   d/x- as needed for these steps and further, make clean sub-repos for testing things out.. the switchenator big repo is fine for that, just make sub-folders to try out the various stages of progress... simple electron js app, one w win32api integration, then onto sjs business as appropriate
   - next up, can make a VERY quick stab at making a scalaJs wrapper .. really dont think should be that painful after getting it working in pure node/electron, and again, there shouldbe examples to look up on how to wrap js in scalaJs, and think it looked like it was pretty straightforward
      x- ELSE however, can just consider writing the shit out in js itself.. cant be that bad, literally thousands of ppl seem to be doing it and saying its easy
   i- anyway, only AFTER that, should seriously consider the app specific stuff, and really, if can validate this far, cranking out the app will be a VERY natural, motivating, and satisfying endeavor, at which point wont have to slave drive myself for it step at a time

   d-- work details list
      i- refer to the node-gyp installation page, esp windows part.. the visual studio build tools works well, will install python as well.. took a couple tries, and it might have restarted windows, though not sure.. also better to run those from actual cmd console rather than from conEmu
      i- on that node-gyp page, ignore the parts about the binding.gyp file etc, not required for just this, and creating that file will ask for srcs etc and prevent the electron app from building
      i- the rebuilding of electron (and ffi/electron-rebuild install) only need to be done once.. even for the project itself only need to do 'install' once, after that can just do npm start and should pick up changed code (at least for the simple changes looks like)
      d-- hmm, at some point it was complaining of not finding node-gyp in the right place, after quick look at https://github.com/nodejs/node-gyp/issues/1463, ended up just making a junction at the right place for the installed node-gyp folder (the err wanted things in ..node_modules/node_modules/node-gyp etc)
      
      i-- however, stuff has been pretty flaky despite this.. sometimes the handles get returned 0 for windows instead of the actual hwnd, adn sometimes they dont activate the windows, but at other times it works.. so not clear if its something addressable locally or something else going on
         - and even that guys sample code calls out on that, and gets around by calling the find window way too many times
         - for us though, we just want the listing business, and that seems to be more robust.. maybe wont have to worry about that find bug much
      
   d-- huh, so got the basics of a nodejs thing working, with some pain on getting node-gyp etc working, but interesting side note from there..
      - looks like it was using ShowWindow (instead of SetForegroundWindow), which might not actually have the same restrictions on what it can activate based on the description at https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-showwindow
      - so, if thats the case, then could keep going w what we were doing before w the server/cli w/o having to do the ffi/node-gyp (although prob still should)
      - also, there's more fns that are similar there, incl 'BringWindowToTop' which also looks similar and unconstrained
      - hmm, and btw, just trying out 'SetForegroundWindow' via npm console w/o triggering browser window still works (in contrast to what we had seen w the background java process triggering that), though presumably because the active process then is the node/npm process which is the active process calling for that to happen, which might be all that was required (jsut that a bkg process was prevented from doing so... hmm, nah, think at least once, go it to do SetForegroundWindow even after going around to activate another window after kicking off npm start.. so who knows)
   
   -- anyway, so def an interesting wrinkle and fork in the path on what to do now given this
      - so, first off, maybe gotta fire that old shite back up, and test to see if it actually works if using ShowWindow, and maybe even just to familiarize again
      - in absolute sense, should definitely go w the client-only node soln w node-gyp and ffi.. should be much faster, avoids pointless server/client roundtrip, avoids having a pointless server process/jvm running, and will be a LOT more easily distributable/shareable etc.. 
      - besides, already have the painful ffi/gyp part mostly going, shouldnt be that hard to hack up something usable going from there
      - and can still do almost everything there in sjs anyway, as the issues w getting it up werent to do w sjs
      - and note that a pure sjs/node sln requires no jvm at all, as ofc thats the point of sjs to compile scala to js and run in v8/node along w electron
      - and besides, whether have that stupid srv process or not, gonna be doing almost all the ui etc work in sjs in electron anyway
      - so really, the only possible reason to try out the old srv/cli jvm thing is to just see if using that alt fn it actually works (just for curiosity sake)
      - and maybe, maybe, if run into issues w sjs + ffi/elec then could hash out something quick, but even then will need to keep working w sjs/elec anyway
      
      
   - k, more work details list.. 
      - so now that, for pure js/node, have got the basics mostly covered, can start looking at doing it in scalajs.. shouldnt be too bad
         - also, spending further time in js is counter-productive as figuring out things like array symantics etc is just not worth the effort here
      - aight, so found a npm win32-api .. prob should have looked for it earlier, but either way, could make it easier to deal w stff in sjs.. but first, should try and get that working in regular js itself.. still runs on ffi etc, so all that prior work is useful, just add it, try it, get it working
         - code is at https://github.com/waitingsong/node-win32-api
         - do note that, it too is just a wrapper, and since we dont need much else of win32 other than what we already have, not much more we get out of it
      - next up can try in sjs, though depending on running into issues, might have to go back to basics in sjs and get that working too if win32-api gives issues
      
      -- anyway, so first off, just want to get anything minimal as is running in sjs.. 
         - and there's some fs code there, see if that works
         - then see if can do similar by just adding a very simple js file/package of ours w a simple exported fn, that we want to call from sjs
         - and if so, then can try and do that w the ffi/win32 sample code that we had
         - else, or if desired afterwards, can do the same setup w the npm packages, though really the step wise progress steps above are likelty to be more reliable
         - and at that, we should be good to go if it works.. else if we take the npms path, will have to work more to figure out how to set code to use those
         - although, there's also the thing our sample was from : https://github.com/MrTimcakes/node-hide, and could try to make that work if doing the 'require' w our own version has issues, but really shouldnt be, and ours will be lot more customizable for our needs than pulling that from npm
         
      -- uhh, looking back after a break again.. so quick path list
         - set up some very basic js scripts outside, and make them callable from scalajs
         - so maybe, first up, look up some very basic script file, use that in an elec project in js itself, making it callable/exportable as a module
         - next up, try and use that same w an sjs project calling externally .. prob the biggest step here
         - then upgrade that to use ffi, again make sure can be used from js which should be straightforward, then try and do that from sjs
         - after that, well we're good to go w adapting the actual code we want to do so and testing it out from the elec/sjs proj
         - ooh, and thats mostly it, then we can start cranking out the actual elec app to do what we actually want!.. which will be nice!
         
      -- slight change of plans
         - saw that example of including ext js dependency.. looks pretty straightforward, so maybe just start that way, but dont want ffi complexity to start out with.. soo, set up in sjs, ext js dependency, to do some very basic js lib stuff.. try it out, see if it works, then put ffi, see if it works, and if so, we're off to the real stuff
   

02/15 .. way later thoughts, on possible ui improvement w/ a narrow icons-only side-panel

   - so, its been a while and this has been shelved for a bit, but the nagging thing does keep coming back, esp when doing heavy duty work w lots of switching, and esp since the newer alt-tab-terminator still doesnt seem to be heading in the right direction despite updates, and the usual vistaswitcher seems substantially slower these days for whatever reason upon the hotkey press
   - anyway, ofc since we're hurting for speed, any of this would only be worthwhile doing if the speed of bringing it up would be fast enough, so gotta check that out first before any fancy ui etc work, and ofc the primary functionality stuff still stands of doing the switching w/ foregrnd/bkgrnd app etc
   
   - anyway, so the ui thought was that to have like a side panel
      - with only icons list, and with all of the same apps windows collapsed
      - and when you hover on, will replace the main list of window w just the windows of that particular app
      - and ofc some way of going back to global as well, maybe when you get into area of bar w/o app icons, or a specific header area etc 
      - would be very handy when have piles of interspersed app windows, esp w chrome, explorer, winmerge etc
      - and ofc, can have some key shortcut to switch around those too etc
   

09/29 .. well SHIIIITTT...
   - looks like while the SetForegroundWindow worked reliably from intepreter during testing, it does NOT work when called in a server process!!
   - basically there seem to be a long list of conditions that MS wants enforced before it allows focus stealing, of particular relevance here, when testing from eclipse, the calling process was foreground and/or received last input event, either of which is sufficient for MS to let it bring some other window to front, but for a bkg serving java process, thats not the case and so its failed.. uhh.. they only end up flashing the taskbar for that thing!
   - makes sense on actual straightforward appswitcher apps too, right before they switch they are taking input so its allowable
   - so anyway, not sure what to do next, could possibly impl the damn thing completely in electron/node w/ some mix of sjs/js and ffi etc, but will be a pain, and not sure how worthwhile it woudl be

09/29 .. aright, so on to adding some actual functionality..

   - so, general functionality in brief : 
      - need backend to query for tasks, compile up into prob json, send over to client, thats it
      - and for frontend, parse that json, display basic list, add scroll/click fn, register hotkey, make window hidden/viz, add sorting, add searching
      
   - much later thoughts / optimization etc, but ONLY to keep in mind while focusing on immdt progress work etc
      - want some speedup, so prob want to have decent cache on FE, and all icon loading etc should be directly on FE ofc
      - prob also means, eventually might not want directly bknd querying on call, but something like bkg updates etc, but not clear how worthwhile that would be, or what would be the fastest way (tick queries, websocket etc), or if thats too resource intensive, or lead to more frequent crashes
      - if early issues seen w jna calls for winamp monitor continue, then on long running, the jna jvm might be crashing, in which case might need more resilient design w a monitor jvm process and supervised/replaceable jvm for actual jna work.. but meh we'll see
      
   - for starters, should hash out the backend part, shouldnt be bad, and can just print out on api call, the json part should be quick too
   - possibly could look at adding the rev api too, to activate something, just to get it over w and usable via api, but prob really not needed for a bit
      - also prob means, for fidelity across changes, that'd prob require actually passing around actual window ids etc
   - and the calling can be directly done when switchenator is invoked, dont worry about lag/speeds etc there for now
   
   - then setup very basic parsing on elec frontend just to print out the list, (just titles is prob fine, later can add exe path, icons etc)
   - should prob add a bknd call right after that to actually allow switching.. on FE, can be on simple click handling (or maybe kbd) etc
   - that'd be pretty minimally usable by then, so should start looking at global hotkey reg to call that up, still dont need to worry about hiding window
   - then can look at reading and showing the icons as thatd be important for usability.. can cache those up for speed
   - then should add sort handling prob, as that prob adds the most immdt value
   - then prob getting win to hide on action (along w showing on hotkey) might be worthwhile, though really, both could prob be skipped, esp the hiding
   - further out, should add the partial-match search ui.. itll be useful, but not something I find wishing for, esp once I'd have sorting/grouping
   - at some point can look at ui prettiness etc.. window locations, menu bars, title bars, bkg, scrolling, maybe even bknd configs!
   - way way down the road could consider packaging into installer etc, but really think might be fine just as is in dev mode potentially forever


09/29 .. operational minimal shell .. reference notes
   -- so, leveraging the setups for nuncer/airenator and the eary shell for airenator nunce sjse app, this was thrown together quickly
   - note that this skeleton was mostly made by copying/deleting/modifying from those mentioned projects, might be some leftovers to clear out still
   - basically consists of a backend (switchback) and electron geared frontend (switchface)
   - for now, keeping them mostly separate, could consider doing some shared business later
   - nevertheless, modeled the structure after nuncer which has a similar single sbt built server/client/shared design, so can add shared stuff later
   - switchback runs on basic straigtforward scalatra, currently just a shell, not planning on pushing any UI stuff unlike for nuncer, just strict API stuff
   - switchface client, looks like a regular scala-js frontend, but with minor tweaks to target for electron running
   - in particular, in main build.sbt, a 'elPack' task takes sjs outputs and massages/copies them to a electron target location
   - a simple npm/electron package.json looks at the location and runs the app (when calling npm start), with hot reload when things there change!
   - and with separate live targets in build.sbt for both server and client code, can have changed to server code auto picked up and deployed to server, client code auto picked and compiled to sjs and moved to electron folder, then npm/electron auto reload the client frontend.. its nice!
      - although do note that the reloading part happens on global change, so any code change will trigger both server and client to rebuild/redeploy, but prob is bearable, and certainly so for this particular proj w/o much internal state
      - and realistically, once backend stabilizes, as its straight forward, might end up doing that w/o hot reload when just working on the client

   
09/29/2018 .. SO IT BEGINS !!

   -- so, the motivation and bkg for this came together quickly, and might be ephemeral, but quick progress has been made, and giving it independent life here
   - anyway, so some more on details and bkg are copied over from elsewhere below, but mostly for historical reasons   
   
   -- PRIOR THOUGHTS HISTORY :
   
      - so instead of doing bunch of pointless recap on more background, copying here some of the relevant notes from elsewhere (running notes dump etc) on what/how and how it progressed to this initial proj as of 09/29
      - basically, was getting annoyed at not being able to sort through task-items in vistaswitcher, and switcheroo though it has search, being worse in most all other areas, so thought was hell, maybe should just try and throw together something quick, esp given the last exploration w java JNA that seemed to work easy and mostly ok, though w questionable stability on long runs
      - initial thoughts were on scalafx etc, but recently had also become aware of electron based 'native' 'webapp' like apps, and though a poor fit here, esp considering the round about manner and pointless memory waste for such a simple and close to native app, was a good excuse to learn it / try it out, and seemed to be easy enough to hack together, so decided to get it going
      - (for context, was also around the same time, had some ui building for 'airenator' in back plate, so kinda of picked it up for both, as although the airenator frontend wouldnt need electron or need to be native, figured might not be much more effort to write the FE in electron rather than just as a webapp anyway, so why not!)

      09/12 .. switcheroo gripes list
         - uhh, really wanted something thatd let me see task list entries sorted by app/type etc, and decided to give a good shot back to switcheroo
         - on plus side, it could be made decent, and might even be something I can update/customize in code if I want, its up in github
         -- on the gripes.. man its nowhere near as ready/usable   
         - freaking scroll scrolls the window instead of scrolling through entries there
         - the hotkey on repressing escapes out of the window instead of doing next like alt-tab's tab, or vistaswitcher's key would 
            - although that seems to work in alt-tab mode, so prob could open a ticket and might be fixable quick
         - and that prob also is why it doesnt actually activate any of the items on single-click, have to double click, how dumb is that, esp since there's nothing there to do on 'select' anyway as there isnt even any right click on the items.. uhh just dumb
         - why is so dog freaking slow!, even the dumb list filtering.. doesnt have to be that slow
         - and ofc, the option to sort by type, or really the option for anything(!) doesnt exist yet   
            - although what would be nice woudl be to add keys like alt-s or alt-g etc to enable that
         - and the devs dont seem particularly updating it either, so its upto me to do it if I want it, though could see if by putting up issue anyone else might be interested to try out or help
         
         - so, could a thought be to instead of trying to hack into that etc, just pull up something like scala-fx and try to build a simple quick thing in it itself? i mean, w jna etc, actual dealing w windows etc seems straightforward
            - though might need to dig just a bit more at getting icons etc
               - def do more search, but options are def available.. e.g: https://stackoverflow.com/questions/19279134/java-windows-taskbar-using-jna-how-do-i-convert-window-icons-hicon-to-java
            - also only tangential, but there's an interesting https://github.com/dorkbox/SystemTray if that feels worthwhile later
         
      09/12 .. hmm following on from the task-list ui, maybe consider for others too
         - might be interesting if doing some/any java-fx work on that app-switcher thought, to maybe just try a hand at scala-fx or whatever the picked soln is for some other quick and dirty stuff too
         - for instance, making one for airenator might not be a bad idea.. 
            - now ofc, really would prob be best suited for a regular web client work, but eh, if want practice, sure maybe
         - although tbh, any 'practice' should really just be done on the switcher app itself, thats perfectly fine for it and actually has immdt use, as well as not being doable even remotely passably in webapp format, so makes it worthwhile.. everything else is perfectly fine as a web app

      09/26 Wed .. heading deep into electron quick apps .. (got through weekend, w gb working, should be plenty of time to get these cranked out!)
         - prob can stall work for a bit w/o imp stuff, maybe create some ticks and put up ws test code, talk about TPS/AP/travel etc through weekend
         - on scalaJs-electron work, maybe crank out airenator first, or realistically could do both simultaneously, should be similar
         d- first get the quickstart samples from git working
         - then build a similar proj structure somewhere, might be easiest on airenator repo
            - update it to have it minimally bringing up a window, sending some quick cmds from btns that can be seen to work in airenator console
            - update airenator core code/api to return full state in json, basically for each call.. might be the easiest to quickly patch up
            - hook up the sjs-e app to consume the airenator json output and have a ui that shows cur state and minimal input to send back in.. thats it!
         - then can move on w hashing out switchenator(?) quickly
            - use similar quickstart skeleton, incl both the backend/frontend parts
            - hack up a quick backend that gives full json output on query, thats all should be needed, dont worry about speedups/optimizing etc for now
            - on client, set up simple listing first of processes, later can add icon disp w icon caching, 
            - then add up kbd hooks for scroll, click, Alt/Enter press etc, impl grouping, impl searching.. thats pretty much it!
   
   


